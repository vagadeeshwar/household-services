from marshmallow import Schema, fields, validate, validates, ValidationError
from ..models import User, Album, Song, Playlist, PlaylistSong, Rating, Flag
from datetime import date, datetime, timezone

# For example, in your case, you have defined custom constraints using the CheckConstraint and regular expression patterns in the __table_args__ of the User model. These custom constraints may not be automatically translated into the Marshmallow schema generated by Marshmallow-SQLAlchemy.
# Even though marshmellow_sqlalchemy reduces the boilerplate code, it has the above disadvantage.


class UserSchema(Schema):
    id = fields.Integer(dump_only=True)
    username = fields.String(required=True, validate=validate.Length(min=2))
    email = fields.Email(required=True)
    password = fields.String(required=True, load_only=True)
    role = fields.String(
        required=True, validate=validate.OneOf(["user", "admin", "creator"])
    )
    created_at = fields.DateTime(dump_only=True)
    gender = fields.String(required=True, validate=validate.OneOf(["M", "F"]))
    dob = fields.Time(allow_none=True)
    mobile_number = fields.String(
        required=True, validate=validate.Regexp(r"^[1-9]\d{11}$")
    )
    image_path = fields.String(allow_none=True)
    albums = fields.Nested("AlbumSchema", many=True, exclude=("user_id",))
    playlists = fields.Nested("PlaylistSchema", many=True, exclude=("user",))
    ratings = fields.Nested("RatingSchema", many=True, exclude=("user",))
    flags = fields.Nested("FlagSchema", many=True, exclude=("user",))

    @validates("dob")
    def validate_dob(self, value):
        if value and value > date.today():
            raise ValidationError("Date of birth cannot be in the future.")


class SongSchema(Schema):
    id = fields.Integer(dump_only=True)
    name = fields.String(required=True, validate=validate.Length(min=2))
    album_id = fields.Integer(required=True, load_only=True)
    lyrics = fields.String(allow_none=True)
    genre = fields.String(allow_none=True, validate=validate.Length(min=2))
    created_at = fields.DateTime(dump_only=True)
    duration = fields.Time(required=True)
    audio_path = fields.String(required=True)
    ratings = fields.Nested("RatingSchema", many=True, exclude=("song_id",))
    flags = fields.Nested("FlagSchema", many=True, exclude=("song_id",))

    @validates("created_at")
    def validate_created_at(self, value):
        if value and value > datetime.now(timezone.utc):
            raise ValidationError("Created date cannot be in the future.")


class AlbumSchema(Schema):
    id = fields.Integer(dump_only=True)
    name = fields.String(required=True, validate=validate.Length(min=2))
    user_id = fields.Integer(required=True, load_only=True)
    created_at = fields.DateTime(dump_only=True)
    description = fields.String(allow_none=True)
    genre = fields.String(allow_none=True, validate=validate.Length(min=2))
    songs = fields.Nested("SongSchema", many=True, exclude=("album_id",))

    @validates("created_at")
    def validate_created_at(self, value):
        if value and value > datetime.now(timezone.utc):
            raise ValidationError("Created date cannot be in the future.")


class PlaylistSchema(Schema):
    id = fields.Integer(dump_only=True)
    name = fields.String(required=True, validate=validate.Length(min=2))
    user_id = fields.Integer(required=True, load_only=True)
    description = fields.String(allow_none=True)
    created_at = fields.DateTime(dump_only=True)
    songs = fields.Nested("SongSchema", many=True, exclude=("playlists",))
    
    @validates("name")
    def validate_unique_playlist_name(self, value):
        existing_playlist = Playlist.query.filter_by(
            name=value, user_id=self.context["user_id"]
        ).first()
        if existing_playlist:
            raise ValidationError("Playlist name must be unique for each user.")


class PlaylistSongSchema(Schema):
    id = fields.Integer(dump_only=True)
    playlist_id = fields.Integer(required=True, load_only=True)
    song_id = fields.Integer(required=True, load_only=True)


class RatingSchema(Schema):
    id = fields.Integer(dump_only=True)
    user_id = fields.Integer(required=True, load_only=True)
    song_id = fields.Integer(required=True, load_only=True)
    rating_value = fields.Integer(required=True, validate=validate.Range(min=1, max=5))


class FlagSchema(Schema):
    id = fields.Integer(dump_only=True)
    user_id = fields.Integer(required=True, load_only=True)
    song_id = fields.Integer(required=True, load_only=True)
    reason = fields.String(allow_none=True)
