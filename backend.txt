This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-29T14:53:18.933Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.flaskenv
.gitignore
celery_diagnostic.py
celerybeat-schedule.dir
config.json
pyproject.toml
README.md
src/__init__.py
src/app.py
src/celery_app.py
src/celeryconfig.py
src/constants.py
src/models.py
src/routes/auth.py
src/routes/customer.py
src/routes/dashboard.py
src/routes/export.py
src/routes/professional.py
src/routes/request.py
src/routes/service.py
src/routes/user.py
src/schemas/auth.py
src/schemas/base.py
src/schemas/customer.py
src/schemas/dashboard.py
src/schemas/export.py
src/schemas/professional.py
src/schemas/request.py
src/schemas/service.py
src/schemas/user.py
src/setup_db.py
src/static/exports/service_requests_1_20241129_194212.csv
src/static/exports/service_requests_3_20241129_201636.csv
src/static/exports/service_requests_5_20241129_201351.csv
src/tasks.py
src/utils/api.py
src/utils/auth.py
src/utils/cache.py
src/utils/file.py
src/utils/notification.py
src/utils/request.py
src/utils/user.py
templates/emails/daily_reminder.html
templates/emails/export_complete.html
templates/emails/monthly_report.html
templates/emails/service_request_assigned.html
templates/emails/verification_approved.html

================================================================
Repository Files
================================================================

================
File: .flaskenv
================
# .flaskenv
FLASK_APP=src.app:app
FLASK_ENV=development
FLASK_DEBUG=1
FLASK_RUN_HOST=0.0.0.0
FLASK_RUN_PORT=8080

================
File: .gitignore
================
# Root-level ignores
.DS_Store
Thumbs.db
.vscode/
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln

# Environment variables
# .env
# .env.local
# .env.development.local
# .env.test.local
# .env.production.local

# Logs
logs/
*.log
*.out
*.pid
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# Sentry files
.sentryclirc

# Optional REPL history
.node_repl_history

# Frontend (Vue.js) specific ignores
frontend/node_modules/
frontend/npm-debug.log*
frontend/yarn-debug.log*
frontend/yarn-error.log*
frontend/dist/
frontend/build/
frontend/.npm
frontend/.eslintcache
frontend/.cache
frontend/public/js
frontend/public/css

# Backend (Flask) specific ignores
*.pyc
*.pyo
*.pyd
__pycache__/
# *.sqlite3
env/
venv/
ENV/
venv.bak/
env.bak/
# instance/
*.log
*.pot
*.py[cod]
# *.db
.webassets-cache
dump.rdb

build/
repopack-output.txt

================
File: celery_diagnostic.py
================
import redis
from src.celery_app import celery
import json


def check_redis_connection():
    """Check Redis broker and backend connections"""
    try:
        # Check broker (DB 1)
        broker = redis.Redis(host="localhost", port=6379, db=1)
        broker.ping()
        print("✅ Redis broker (DB 1) is connected")

        # Check result backend (DB 2)
        backend = redis.Redis(host="localhost", port=6379, db=2)
        backend.ping()
        print("✅ Redis result backend (DB 2) is connected")

    except Exception as e:
        print(f"❌ Redis error: {e}")


def check_task_status(task_id):
    """Check status of a specific task"""
    try:
        # Get AsyncResult
        result = celery.AsyncResult(task_id)
        print(f"\nTask Status for {task_id}:")
        print(f"Status: {result.status}")
        print(f"Ready: {result.ready()}")

        # Try to get task result from Redis directly
        r = redis.Redis(host="localhost", port=6379, db=2)
        result_key = f"celery-task-meta-{task_id}"
        raw_result = r.get(result_key)

        if raw_result:
            result_data = json.loads(raw_result)
            print("\nRaw result from Redis:")
            print(json.dumps(result_data, indent=2))
        else:
            print("\nNo result found in Redis")

    except Exception as e:
        print(f"❌ Error checking task: {e}")


def check_active_workers():
    """Check for active Celery workers"""
    try:
        i = celery.control.inspect()

        # Get active workers
        active = i.active()
        if active:
            print("\n✅ Active workers found:")
            for worker, tasks in active.items():
                print(f"Worker: {worker}")
                print(f"Active tasks: {len(tasks)}")
        else:
            print("\n❌ No active workers found!")

        # Check registered tasks
        registered = i.registered()
        if registered:
            print("\nRegistered tasks:")
            for worker, tasks in registered.items():
                print(f"\nWorker {worker} tasks:")
                for task in tasks:
                    print(f"  - {task}")

    except Exception as e:
        print(f"❌ Error checking workers: {e}")


if __name__ == "__main__":
    print("Running Celery diagnostics...\n")

    print("1. Checking Redis connections...")
    check_redis_connection()

    print("\n2. Checking workers...")
    check_active_workers()

    # Check specific task if ID provided
    task_id = input("\nEnter task ID to check (or press Enter to skip): ").strip()
    if task_id:
        check_task_status(task_id)

================
File: celerybeat-schedule.dir
================
'entries', (0, 443)
'__version__', (512, 20)
'tz', (1024, 18)
'utc_enabled', (1536, 4)

================
File: config.json
================
{}

================
File: pyproject.toml
================
[tool.poetry]

name = "household-services"
version = "0.1.0"
description = ""
authors = ["Vagadeeshwar G <21f1005494@ds.study.iitm.ac.in>"]
readme = "README.md"
# package-mode = false

[tool.poetry.dependencies]
python = "^3.12"
flask = "^3.0.3"
python-dotenv = "^1.0.1"
flask-sqlalchemy = "^3.1.1"
flask-restful = "^0.3.10"
flask-cors = "^5.0.0"
flask-marshmallow = "^1.2.1"
pyjwt = "^2.10.0"
marshmallow-sqlalchemy = "^1.1.0"
redis = "^5.2.0"
flask-caching = "^2.3.0"
celery = "^5.4.0"
flower = "^2.0.1"
flask-mail = "^0.10.0"

[tool.poetry.group.dev.dependencies]
faker = "^33.0.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

================
File: README.md
================
# Coming soon

================
File: src/__init__.py
================
from flask_sqlalchemy import SQLAlchemy
from flask_marshmallow import Marshmallow

db = SQLAlchemy()
ma = Marshmallow()

================
File: src/app.py
================
import os
from flask import Flask, send_from_directory
from flask_cors import CORS
from dotenv import load_dotenv

from src import db, ma

from src.setup_db import setup_database  # noqa

from src.utils.api import register_error_handlers
from src.utils.file import UPLOAD_FOLDER
from src.utils.cache import init_cache
from src.utils.notification import mail


def create_app():
    # Initialize Flask app
    app = Flask(__name__, static_folder="../build", static_url_path="")
    CORS(app)
    load_dotenv()

    # Configuration
    app.config["SQLALCHEMY_DATABASE_URI"] = os.getenv(
        "SQLALCHEMY_DATABASE_URI", "sqlite:///database.sqlite3"
    )
    app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
    app.config["SECRET_KEY"] = os.getenv("SECRET_KEY", "your-secret-key-here")

    app.config.update(
        MAIL_SERVER="smtp.gmail.com",
        MAIL_PORT=587,
        MAIL_USE_TLS=True,
        MAIL_USERNAME=os.getenv("MAIL_USERNAME"),
        MAIL_PASSWORD=os.getenv("MAIL_PASSWORD"),
        MAIL_DEFAULT_SENDER=os.getenv(
            "MAIL_DEFAULT_SENDER", "noreply@householdservices.com"
        ),
        MAIL_DEBUG=True,  # Add this for debugging
    )

    # Initialize extensions
    db.init_app(app)
    ma.init_app(app)
    init_cache(app)
    mail.init_app(app)

    # with app.app_context():
    #     setup_database()

    # Register blueprints
    from src.routes.user import user_bp
    from src.routes.customer import customer_bp
    from src.routes.professional import professional_bp
    from src.routes.auth import auth_bp
    from src.routes.service import service_bp
    from src.routes.dashboard import dashboard_bp
    from src.routes.request import request_bp
    from src.routes.export import export_bp

    app.register_blueprint(user_bp, url_prefix="/api")
    app.register_blueprint(customer_bp, url_prefix="/api")
    app.register_blueprint(professional_bp, url_prefix="/api")
    app.register_blueprint(auth_bp, url_prefix="/api")
    app.register_blueprint(service_bp, url_prefix="/api")
    app.register_blueprint(dashboard_bp, url_prefix="/api")
    app.register_blueprint(request_bp, url_prefix="/api")
    app.register_blueprint(export_bp, url_prefix="/api")

    # Register error handler
    register_error_handlers(app)

    @app.route("/static/uploads/verification_docs/<path:filename>")
    def serve_verification_document(filename):
        """Serve verification documents"""
        return send_from_directory(os.path.join(app.root_path, UPLOAD_FOLDER), filename)

    # Serve SPA
    @app.route("/", defaults={"path": ""})
    @app.route("/<path:path>")
    def serve_vue_app(path):
        try:
            if path and os.path.exists(os.path.join(app.static_folder, path)):
                return send_from_directory(app.static_folder, path)
            return send_from_directory(app.static_folder, "index.html")
        except Exception:
            return send_from_directory(app.static_folder, "index.html")

    return app


app = create_app()

================
File: src/celery_app.py
================
# src/celery_app.py
from celery import Celery

# Initialize Celery
celery = Celery(
    "household_services",
    broker="redis://localhost:6379/1",
    backend="redis://localhost:6379/2",
    include=["src.tasks"],  # Explicitly include tasks module
)

# Configure Celery
celery.conf.update(
    task_serializer="json",
    accept_content=["json"],
    result_serializer="json",
    timezone="UTC",
    enable_utc=True,
    worker_pool_restarts=True,  # Enable worker pool restarts
    task_track_started=True,  # Track when tasks start
    task_ignore_result=False,  # Enable result backend
    worker_send_task_events=True,  # Enable task events
    task_send_sent_event=True,  # Enable sent event
)

# Load additional configurations
celery.config_from_object("src.celeryconfig")

================
File: src/celeryconfig.py
================
# src/celeryconfig.py
from kombu import Exchange, Queue

# Broker settings
broker_url = "redis://localhost:6379/1"
result_backend = "redis://localhost:6379/2"

# Fix deprecation warning
broker_connection_retry_on_startup = True

# Timezone
timezone = "UTC"

# Task settings
task_serializer = "json"
result_serializer = "json"
accept_content = ["json"]
task_default_queue = "default"

# Queue configuration
task_queues = (
    Queue("default", Exchange("default"), routing_key="default"),
    Queue("reports", Exchange("reports"), routing_key="reports"),
    Queue("notifications", Exchange("notifications"), routing_key="notifications"),
)

# Route tasks to specific queues
task_routes = {
    "src.tasks.send_daily_reminders": {"queue": "notifications"},
    "src.tasks.generate_monthly_reports": {"queue": "reports"},
}

# Task execution settings
task_always_eager = False
task_acks_late = True
worker_prefetch_multiplier = 1

# Task time limits - adjusted for Windows
task_time_limit = None  # Disable hard timeout on Windows
task_soft_time_limit = None  # Disable soft timeout on Windows

# Result settings
result_expires = 3600  # 1 hour

# Logging
worker_redirect_stdouts = False
worker_redirect_stdouts_level = "INFO"

# Beat settings
beat_schedule = {
    "daily-reminders": {
        "task": "src.tasks.send_daily_reminders",
        "schedule": 60.0 * 60 * 24,  # daily
        "options": {"queue": "notifications"},
    },
    "monthly-reports": {
        "task": "src.tasks.generate_monthly_reports",
        "schedule": 60.0 * 60 * 24 * 30,  # monthly
        "options": {"queue": "reports"},
    },
}

================
File: src/constants.py
================
USER_ROLE_ADMIN = "admin"
USER_ROLE_PROFESSIONAL = "professional"
USER_ROLE_CUSTOMER = "customer"
USER_ROLES = [USER_ROLE_ADMIN, USER_ROLE_PROFESSIONAL, USER_ROLE_CUSTOMER]

REQUEST_STATUS_CREATED = "created"
REQUEST_STATUS_ASSIGNED = "assigned"
REQUEST_STATUS_COMPLETED = "completed"
REQUEST_STATUSES = [
    REQUEST_STATUS_CREATED,
    REQUEST_STATUS_ASSIGNED,
    REQUEST_STATUS_COMPLETED,
]

# User Management Actions
USER_LOGIN = "user_login"
USER_REGISTER = "user_register"
USER_PROFILE_UPDATE = "profile_update"
USER_PASSWORD_CHANGE = "password_change"
USER_DELETE = "user_delete"

# Professional Management Actions
PROFESSIONAL_VERIFY = "professional_verify"
PROFESSIONAL_BLOCK = "professional_block"
PROFESSIONAL_UNBLOCK = "professional_unblock"
PROFESSIONAL_DOCUMENT_UPDATE = "document_update"
PROFESSIONAL_SERVICE_UPDATE = "service_update"

# Customer Management Actions
CUSTOMER_BLOCK = "customer_block"
CUSTOMER_UNBLOCK = "customer_unblock"

# Service Management Actions
SERVICE_CREATE = "service_create"
SERVICE_UPDATE = "service_update"
SERVICE_DELETE = "service_delete"
SERVICE_RESTORE = "service_restore"

# Request Management Actions
REQUEST_CREATE = "request_create"
REQUEST_ASSIGN = "request_assign"
REQUEST_UPDATE = "request_update"
REQUEST_COMPLETE = "request_complete"
REQUEST_REVIEWED = "request_reviewed"
REQUEST_CANCEL = "request_cancel"

# Review Management Actions
REVIEW_SUBMIT = "review_submit"
REVIEW_REPORT = "review_report"
REVIEW_DISMISS = "review_dismiss"
REVIEW_REMOVE = "review_remove"

# Payment Related Actions (if needed in future)
# PAYMENT_INITIATE = "payment_initiate"
# PAYMENT_SUCCESS = "payment_success"
# PAYMENT_FAIL = "payment_fail"
# PAYMENT_REFUND = "payment_refund"

# Admin Actions
# ADMIN_SETTINGS_UPDATE = "settings_update"
# ADMIN_BULK_ACTION = "bulk_action"

# System Actions
# SYSTEM_MAINTENANCE = "system_maintenance"
# SYSTEM_ERROR = "system_error"


# Group these constants in a class for better organization
class ActivityLogActions:
    """Constants for activity log actions"""

    # User Management
    USER_LOGIN = USER_LOGIN
    USER_REGISTER = USER_REGISTER
    USER_PROFILE_UPDATE = USER_PROFILE_UPDATE
    USER_PASSWORD_CHANGE = USER_PASSWORD_CHANGE
    USER_DELETE = USER_DELETE

    # Professional Management
    PROFESSIONAL_VERIFY = PROFESSIONAL_VERIFY
    PROFESSIONAL_BLOCK = PROFESSIONAL_BLOCK
    PROFESSIONAL_UNBLOCK = PROFESSIONAL_UNBLOCK
    PROFESSIONAL_DOCUMENT_UPDATE = PROFESSIONAL_DOCUMENT_UPDATE
    PROFESSIONAL_SERVICE_UPDATE = PROFESSIONAL_SERVICE_UPDATE

    # Customer Management
    CUSTOMER_BLOCK = CUSTOMER_BLOCK
    CUSTOMER_UNBLOCK = CUSTOMER_UNBLOCK

    # Service Management
    SERVICE_CREATE = SERVICE_CREATE
    SERVICE_UPDATE = SERVICE_UPDATE
    SERVICE_DELETE = SERVICE_DELETE
    SERVICE_RESTORE = SERVICE_RESTORE

    # Request Management
    REQUEST_CREATE = REQUEST_CREATE
    REQUEST_ASSIGN = REQUEST_ASSIGN
    REQUEST_UPDATE = REQUEST_UPDATE
    REQUEST_COMPLETE = REQUEST_COMPLETE
    REQUEST_CANCEL = REQUEST_CANCEL
    REQUEST_REVIEWED = REQUEST_REVIEWED

    # Review Management
    REVIEW_SUBMIT = REVIEW_SUBMIT
    REVIEW_REPORT = REVIEW_REPORT
    REVIEW_DISMISS = REVIEW_DISMISS
    REVIEW_REMOVE = REVIEW_REMOVE

    # Payment Related
    # PAYMENT_INITIATE = PAYMENT_INITIATE
    # PAYMENT_SUCCESS = PAYMENT_SUCCESS
    # PAYMENT_FAIL = PAYMENT_FAIL
    # PAYMENT_REFUND = PAYMENT_REFUND

    # # Admin Actions
    # ADMIN_SETTINGS_UPDATE = ADMIN_SETTINGS_UPDATE
    # ADMIN_BULK_ACTION = ADMIN_BULK_ACTION

    # # System Actions
    # SYSTEM_MAINTENANCE = SYSTEM_MAINTENANCE
    # SYSTEM_ERROR = SYSTEM_ERROR

    @classmethod
    def get_all_actions(cls):
        """Returns list of all valid activity log actions"""
        return [
            getattr(cls, attr)
            for attr in dir(cls)
            if not attr.startswith("_") and isinstance(getattr(cls, attr), str)
        ]

================
File: src/models.py
================
from datetime import datetime
from sqlalchemy.orm import relationship
from werkzeug.security import generate_password_hash, check_password_hash
from sqlalchemy.schema import CheckConstraint, Index

from src import db

from src.constants import (
    USER_ROLES,
    REQUEST_STATUSES,
    REQUEST_STATUS_CREATED,
    ActivityLogActions,
)


class TimestampMixin:
    """Mixin for created and updated timestamps"""

    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)


class User(db.Model, TimestampMixin):
    """Base User Model for all types of users"""

    __tablename__ = "users"

    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    full_name = db.Column(db.String(100), nullable=False)
    address = db.Column(db.Text, nullable=False)
    phone = db.Column(
        db.String(10), CheckConstraint("length(phone) = 10"), nullable=False
    )
    pin_code = db.Column(
        db.String(6), CheckConstraint("length(pin_code) = 6"), nullable=False
    )
    password_hash = db.Column(db.String(256), nullable=False)
    role = db.Column(db.String(20), nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    last_login = db.Column(db.DateTime)

    # Relationships with cascade
    professional_profile = relationship(
        "ProfessionalProfile",
        back_populates="user",
        uselist=False,
        cascade="all, delete-orphan",
    )
    customer_profile = relationship(
        "CustomerProfile",
        back_populates="user",
        uselist=False,
        cascade="all, delete-orphan",
    )

    __table_args__ = (
        CheckConstraint(f"role IN {tuple(USER_ROLES)}", name="valid_role_types"),
        Index("idx_user_username", username, unique=True),
        Index("idx_user_email", email, unique=True),
        Index("idx_user_role_active", role, is_active),
        Index("idx_user_pincode", pin_code),
    )

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f"<User {self.username} ({self.role})>"


class ProfessionalProfile(db.Model, TimestampMixin):
    """Profile for service professionals"""

    __tablename__ = "professional_profiles"

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(
        db.Integer,
        db.ForeignKey("users.id", ondelete="CASCADE", onupdate="CASCADE"),
        unique=True,
        nullable=False,
    )
    description = db.Column(db.Text)
    is_verified = db.Column(db.Boolean, default=False)
    verification_documents = db.Column(db.String(500))
    service_type_id = db.Column(
        db.Integer,
        db.ForeignKey("services.id", ondelete="RESTRICT", onupdate="CASCADE"),
        nullable=False,
    )
    experience_years = db.Column(
        db.Integer, CheckConstraint("experience_years >= 0"), nullable=False
    )
    average_rating = db.Column(
        db.Float,
        CheckConstraint("average_rating >= 0 AND average_rating <= 5"),
        default=0.0,
    )

    # Relationships with cascade
    user = relationship("User", back_populates="professional_profile")
    service_type = relationship("Service", back_populates="professionals")
    service_requests = relationship(
        "ServiceRequest", back_populates="professional", cascade="all, delete-orphan"
    )

    __table_args__ = (
        Index("idx_prof_verified_service", is_verified, service_type_id),
        Index("idx_prof_rating", average_rating),
    )


class CustomerProfile(db.Model, TimestampMixin):
    """Profile for customers"""

    __tablename__ = "customer_profiles"

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(
        db.Integer,
        db.ForeignKey("users.id", ondelete="CASCADE", onupdate="CASCADE"),
        unique=True,
        nullable=False,
    )

    # Relationships with cascade
    user = relationship("User", back_populates="customer_profile")
    service_requests = relationship(
        "ServiceRequest", back_populates="customer", cascade="all, delete-orphan"
    )


class Service(db.Model, TimestampMixin):
    """Service types available on the platform"""

    __tablename__ = "services"

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, unique=True)
    description = db.Column(db.Text, nullable=False)
    base_price = db.Column(db.Float, nullable=False)
    estimated_time = db.Column(db.Integer, nullable=False)
    is_active = db.Column(db.Boolean, default=True)

    # Relationships with cascade
    professionals = relationship(
        "ProfessionalProfile",
        back_populates="service_type",
        cascade="all, delete-orphan",
    )
    service_requests = relationship(
        "ServiceRequest", back_populates="service", cascade="all, delete-orphan"
    )

    __table_args__ = (
        Index("idx_service_active_name", is_active, name),
        Index("idx_service_price", base_price),
    )


class ServiceRequest(db.Model, TimestampMixin):
    """Service requests from customers"""

    __tablename__ = "service_requests"

    id = db.Column(db.Integer, primary_key=True)
    service_id = db.Column(
        db.Integer,
        db.ForeignKey("services.id", ondelete="CASCADE", onupdate="CASCADE"),
        nullable=False,
    )
    customer_id = db.Column(
        db.Integer,
        db.ForeignKey("customer_profiles.id", ondelete="CASCADE", onupdate="CASCADE"),
        nullable=False,
    )
    professional_id = db.Column(
        db.Integer,
        db.ForeignKey(
            "professional_profiles.id", ondelete="SET NULL", onupdate="CASCADE"
        ),
    )

    date_of_request = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
    preferred_time = db.Column(db.DateTime, nullable=False)
    description = db.Column(db.Text, nullable=False)
    status = db.Column(db.String(20), nullable=False, default=REQUEST_STATUS_CREATED)
    date_of_assignment = db.Column(db.DateTime)
    date_of_completion = db.Column(db.DateTime)
    remarks = db.Column(db.Text)

    # Relationships with cascade
    service = relationship("Service", back_populates="service_requests")
    customer = relationship("CustomerProfile", back_populates="service_requests")
    professional = relationship(
        "ProfessionalProfile", back_populates="service_requests"
    )
    review = relationship(
        "Review",
        back_populates="service_request",
        uselist=False,
        cascade="all, delete-orphan",
    )

    __table_args__ = (
        CheckConstraint(
            f"status IN {tuple(REQUEST_STATUSES)}", name="valid_status_types"
        ),
        Index("idx_request_prof_status", professional_id, status),
        Index("idx_request_customer_status", customer_id, status),
        Index("idx_request_dates", preferred_time, date_of_completion),
    )


class Review(db.Model, TimestampMixin):
    """Reviews for completed services"""

    __tablename__ = "reviews"

    id = db.Column(db.Integer, primary_key=True)
    service_request_id = db.Column(
        db.Integer,
        db.ForeignKey("service_requests.id", ondelete="CASCADE", onupdate="CASCADE"),
        unique=True,
        nullable=False,
    )
    rating = db.Column(
        db.Integer, CheckConstraint("rating >= 1 AND rating <= 5"), nullable=False
    )
    comment = db.Column(db.Text)
    is_reported = db.Column(db.Boolean, default=False)
    report_reason = db.Column(db.Text)

    # Relationships with cascade
    service_request = relationship("ServiceRequest", back_populates="review")

    __table_args__ = (
        Index("idx_review_rating", rating),
        Index("idx_review_reported", is_reported),
    )


class ActivityLog(db.Model, TimestampMixin):
    """Audit trail for important activities"""

    __tablename__ = "activity_logs"

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(
        db.Integer, db.ForeignKey("users.id", ondelete="SET NULL", onupdate="CASCADE")
    )
    entity_id = db.Column(db.Integer, nullable=True)
    action = db.Column(
        db.String(50),
        nullable=False,
    )
    description = db.Column(db.Text, nullable=False)

    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)

    __table_args__ = (
        db.CheckConstraint(
            f"action IN {tuple(ActivityLogActions.get_all_actions())}",
            name="valid_action_types",
        ),
        Index("idx_activity_action_time", action, created_at),
        Index("idx_activity_user", user_id),
    )

    def __repr__(self):
        return f"<ActivityLog {self.action} by User {self.user_id}>"

================
File: src/routes/auth.py
================
from flask import Blueprint, request
from datetime import datetime
from marshmallow import ValidationError
from http import HTTPStatus

from src import db

from src.models import (
    User,
    ActivityLog,
)

from src.constants import (
    ActivityLogActions,
)

from src.schemas.auth import (
    login_schema,
    token_schema,
)

from src.utils.auth import generate_token, APIResponse

auth_bp = Blueprint("auth", __name__)


@auth_bp.route("/login", methods=["POST"])
def login():
    """Login route for all user types"""
    try:
        data = login_schema.load(request.get_json())
    except ValidationError as err:
        return APIResponse.error(str(err.messages))

    user = User.query.filter_by(username=data["username"]).first()

    if not user or not user.check_password(data["password"]):
        return APIResponse.error(
            "Invalid credentials", HTTPStatus.UNAUTHORIZED, "InvalidCredentials"
        )

    if not user.is_active:
        return APIResponse.error(
            "Account is deactivated", HTTPStatus.FORBIDDEN, "InactiveAccount"
        )

    try:
        user.last_login = datetime.utcnow()

        log = ActivityLog(
            user_id=user.id,
            action=ActivityLogActions.USER_LOGIN,
            description=f"User {user.username} logged in successfully",
        )
        db.session.add(log)
        db.session.commit()

        token = generate_token(user.id, user.role)
        return APIResponse.success(
            data=token_schema.dump({"token": token}), message="Login successful"
        )
    except Exception as e:
        return APIResponse.error(
            f"Error during login: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )

================
File: src/routes/customer.py
================
from flask import Blueprint, request
from marshmallow import ValidationError
from http import HTTPStatus

from src import db

from src.models import (
    User,
    CustomerProfile,
    ActivityLog,
)

from src.constants import ActivityLogActions, USER_ROLE_CUSTOMER


from src.schemas.customer import (
    customer_query_schema,
    customer_register_schema,
    customer_output_schema,
    customers_output_schema,
)
from src.schemas.user import block_user_schema

from src.utils.auth import token_required, role_required
from src.utils.api import APIResponse
from src.utils.user import check_existing_user


customer_bp = Blueprint("customer", __name__)


@customer_bp.route("/register/customer", methods=["POST"])
def register_customer():
    """Register a new customer"""
    try:
        data = customer_register_schema.load(request.get_json())
    except ValidationError as err:
        return APIResponse.error(str(err.messages))

    exists, error_response = check_existing_user(data["username"], data["email"])
    if exists:
        return error_response

    try:
        user = User(
            username=data["username"],
            email=data["email"],
            full_name=data["full_name"],
            phone=data["phone"],
            address=data["address"],
            pin_code=data["pin_code"],
            role=USER_ROLE_CUSTOMER,
            is_active=True,
        )
        user.set_password(data["password"])
        db.session.add(user)
        db.session.flush()

        profile = CustomerProfile(user_id=user.id)
        db.session.add(profile)

        log = ActivityLog(
            user_id=user.id,
            action=ActivityLogActions.USER_REGISTER,
            description=f"New customer account created for {user.username}",
        )
        db.session.add(log)
        db.session.commit()

        return APIResponse.success(
            data=customer_output_schema.dump(user),
            message="Customer registered successfully",
            status_code=HTTPStatus.CREATED,
        )
    except Exception as e:
        return APIResponse.error(
            f"Error creating customer: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@customer_bp.route("/customers", methods=["GET"])
@customer_bp.route("/customers/<int:profile_id>", methods=["GET"])
@token_required
@role_required("admin")
def list_customers(current_user, profile_id=None):
    """List all customers or get a specific customer by ID"""
    try:
        if profile_id is not None:
            # Single customer retrieval
            profile = (
                CustomerProfile.query.join(User)
                .filter(CustomerProfile.id == profile_id)
                .first_or_404()
            )

            return APIResponse.success(
                data=customer_output_schema.dump(profile.user),  # Use the schema here
                message="Customer retrieved successfully",
            )

        # List all customers
        params = customer_query_schema.load(request.args)
        query = User.query.join(CustomerProfile).filter(User.role == USER_ROLE_CUSTOMER)

        if params.get("active") is not None:
            query = query.filter(User.is_active == params["active"])
        if params.get("pin_code"):
            query = query.filter(User.pin_code == params["pin_code"])
        
        try:
            paginated = query.paginate(
                page=params["page"], per_page=params["per_page"], error_out=False
            )
        except Exception as e:
            return APIResponse.error(
                f"Pagination error: {str(e)}", HTTPStatus.BAD_REQUEST, "PaginationError"
            )

        return APIResponse.success(
            data=customers_output_schema.dump(paginated.items),
            message="Customers retrieved successfully",
            pagination={
                "total": paginated.total,
                "pages": paginated.pages,
                "current_page": paginated.page,
                "per_page": paginated.per_page,
                "has_next": paginated.has_next,
                "has_prev": paginated.has_prev,
            },
        )
    except ValidationError as err:
        return APIResponse.error(str(err.messages))
    except Exception as e:
        return APIResponse.error(
            f"Error retrieving customers: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@customer_bp.route("/customers/<int:profile_id>/block", methods=["POST"])
@token_required
@role_required("admin")
def block_customer(current_user, profile_id):
    """Block a customer's account"""
    try:
        data = block_user_schema.load(request.get_json())
        profile = CustomerProfile.query.get_or_404(profile_id)

        if not profile.user.is_active:
            return APIResponse.error(
                "Customer is already blocked", HTTPStatus.CONFLICT, "AlreadyBlocked"
            )

        profile.user.is_active = False

        log = ActivityLog(
            user_id=current_user.id,
            action=ActivityLogActions.CUSTOMER_BLOCK,
            entity_id=profile.user.id,
            description=f"Blocked customer {profile.user.full_name}. Reason: {data['reason']}",
        )
        db.session.add(log)
        db.session.commit()

        return APIResponse.success(message="Customer blocked successfully")
    except ValidationError as err:
        return APIResponse.error(str(err.messages))
    except Exception as e:
        return APIResponse.error(
            f"Error blocking customer: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )

================
File: src/routes/dashboard.py
================
# src/routes/dashboard/routes.py
from flask import Blueprint, request
from marshmallow import ValidationError
from sqlalchemy import func, desc
from http import HTTPStatus

from src.models import (
    User,
    ProfessionalProfile,
    CustomerProfile,
    ServiceRequest,
    Review,
    ActivityLog,
    Service,
    db,
)

from src.constants import (
    REQUEST_STATUS_CREATED,
    REQUEST_STATUS_COMPLETED,
    REQUEST_STATUS_ASSIGNED,
)

from src.schemas.dashboard import (
    activity_logs_schema,
    activity_log_query_schema,
    detailed_stats_query_schema,
    dashboard_stats_schema,
)
from src.schemas.professional import professionals_output_schema
from src.schemas.customer import customers_output_schema
from src.schemas.request import service_requests_output_schema, reviews_output_schema
from src.schemas.service import services_output_schema

from src.utils.auth import token_required
from src.utils.api import APIResponse
from src.utils.cache import cached_with_auth

dashboard_bp = Blueprint("dashboard", __name__)


@dashboard_bp.route("/dashboard-stats", methods=["GET"])
@token_required
@cached_with_auth(timeout=60)
def get_dashboard_stats(current_user):
    """Get role-specific dashboard statistics"""
    try:
        stats = {}

        if current_user.role == "admin":
            # Admin sees platform-wide statistics
            stats = {
                "total_professionals": ProfessionalProfile.query.count(),
                "verified_professionals": ProfessionalProfile.query.filter_by(
                    is_verified=True
                ).count(),
                "total_customers": CustomerProfile.query.count(),
                "active_customers": CustomerProfile.query.join(User)
                .filter(User.is_active)
                .count(),
                "pending_verifications": ProfessionalProfile.query.filter_by(
                    is_verified=False
                ).count(),
                "reported_reviews": Review.query.filter_by(is_reported=True).count(),
                "service_requests": {
                    "total": ServiceRequest.query.count(),
                    "pending": ServiceRequest.query.filter_by(
                        status=REQUEST_STATUS_CREATED
                    ).count(),
                    "completed": ServiceRequest.query.filter_by(
                        status=REQUEST_STATUS_COMPLETED
                    ).count(),
                },
            }

        elif current_user.role == "professional":
            # Professional sees their service-related statistics
            professional = current_user.professional_profile
            if not professional:
                return APIResponse.error(
                    "Professional profile not found", HTTPStatus.NOT_FOUND
                )

            total_requests = ServiceRequest.query.filter_by(
                professional_id=professional.id
            )
            stats = {
                "profile_status": {
                    "is_verified": professional.is_verified,
                    "is_active": current_user.is_active,
                    "average_rating": professional.average_rating or 0.0,
                },
                "service_requests": {
                    "total": total_requests.count(),
                    "active": total_requests.filter_by(
                        status=REQUEST_STATUS_ASSIGNED
                    ).count(),
                    "completed": total_requests.filter_by(
                        status=REQUEST_STATUS_COMPLETED
                    ).count(),
                    "pending_review": Review.query.join(ServiceRequest)
                    .filter(
                        ServiceRequest.professional_id == professional.id,
                        ServiceRequest.status == REQUEST_STATUS_COMPLETED,
                    )
                    .count(),
                },
                "reviews": {
                    "total": Review.query.join(ServiceRequest)
                    .filter(ServiceRequest.professional_id == professional.id)
                    .count(),
                    "average_rating": db.session.query(func.avg(Review.rating))
                    .join(ServiceRequest)
                    .filter(ServiceRequest.professional_id == professional.id)
                    .scalar()
                    or 0.0,
                    "reported": Review.query.join(ServiceRequest)
                    .filter(
                        ServiceRequest.professional_id == professional.id,
                        Review.is_reported == True,  # noqa: E712
                    )
                    .count(),
                },
            }

        elif current_user.role == "customer":
            # Customer sees their request-related statistics
            customer = current_user.customer_profile
            if not customer:
                return APIResponse.error(
                    "Customer profile not found", HTTPStatus.NOT_FOUND
                )

            customer_requests = ServiceRequest.query.filter_by(customer_id=customer.id)
            stats = {
                "service_requests": {
                    "total": customer_requests.count(),
                    "active": customer_requests.filter_by(
                        status=REQUEST_STATUS_ASSIGNED
                    ).count(),
                    "pending": customer_requests.filter_by(
                        status=REQUEST_STATUS_CREATED
                    ).count(),
                    "completed": customer_requests.filter_by(
                        status=REQUEST_STATUS_COMPLETED
                    ).count(),
                },
                "reviews_given": Review.query.join(ServiceRequest)
                .filter(ServiceRequest.customer_id == customer.id)
                .count(),
                "recent_services": Service.query.join(ServiceRequest)
                .filter(ServiceRequest.customer_id == customer.id)
                .group_by(Service.id)
                .count(),
            }

        return APIResponse.success(
            data=dashboard_stats_schema.dump(stats),
            message="Dashboard statistics retrieved successfully",
        )

    except Exception as e:
        return APIResponse.error(
            f"Error retrieving dashboard statistics: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@dashboard_bp.route("/activity-logs", methods=["GET"])
@token_required
def list_activity_logs(current_user):
    """Get role-specific paginated activity logs"""
    try:
        params = activity_log_query_schema.load(request.args)
        query = ActivityLog.query

        # Base query depends on user role
        if current_user.role == "admin":
            # Admin can see all activities
            pass
        else:
            # Others can only see their own activities
            query = query.filter(ActivityLog.user_id == current_user.id)

        # Apply common filters
        if params.get("action"):
            query = query.filter(ActivityLog.action == params["action"])
        if params.get("start_date"):
            query = query.filter(ActivityLog.created_at >= params["start_date"])
        if params.get("end_date"):
            query = query.filter(ActivityLog.created_at <= params["end_date"])

        # Always order by latest first
        query = query.order_by(ActivityLog.created_at.desc())

        # Apply pagination
        paginated = query.paginate(
            page=params["page"], per_page=params["per_page"], error_out=False
        )

        return APIResponse.success(
            data=activity_logs_schema.dump(paginated.items),
            message="Activity logs retrieved successfully",
            pagination={
                "total": paginated.total,
                "pages": paginated.pages,
                "current_page": paginated.page,
                "per_page": paginated.per_page,
                "has_next": paginated.has_next,
                "has_prev": paginated.has_prev,
            },
        )

    except ValidationError as err:
        return APIResponse.error(str(err.messages))
    except Exception as e:
        return APIResponse.error(
            f"Error retrieving activity logs: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@dashboard_bp.route("/detailed-stats", methods=["GET"])
@token_required
def get_detailed_stats(current_user):
    """Get role-specific detailed statistics with pagination"""
    try:
        params = detailed_stats_query_schema.load(request.args)

        # Define available stat types for each role
        stat_types = {
            "admin": {
                "pending_verifications": lambda: (
                    ProfessionalProfile.query.filter_by(is_verified=False)
                    .join(User)
                    .order_by(desc(ProfessionalProfile.created_at)),
                    professionals_output_schema,
                ),
                "reported_reviews": lambda: (
                    Review.query.filter_by(is_reported=True).order_by(
                        desc(Review.created_at)
                    ),
                    reviews_output_schema,
                ),
                "recent_professionals": lambda: (
                    User.query.filter_by(role="professional").order_by(
                        desc(User.created_at)
                    ),
                    professionals_output_schema,
                ),
                "recent_customers": lambda: (
                    User.query.filter_by(role="customer").order_by(
                        desc(User.created_at)
                    ),
                    customers_output_schema,
                ),
                "recent_requests": lambda: (
                    ServiceRequest.query.order_by(desc(ServiceRequest.date_of_request)),
                    service_requests_output_schema,
                ),
            },
            "professional": {
                "pending_requests": lambda: (
                    ServiceRequest.query.filter_by(
                        service_id=current_user.professional_profile.service_type_id,
                        status=REQUEST_STATUS_CREATED,
                    ).order_by(desc(ServiceRequest.date_of_request)),
                    service_requests_output_schema,
                ),
                "active_requests": lambda: (
                    ServiceRequest.query.filter_by(
                        professional_id=current_user.professional_profile.id,
                        status=REQUEST_STATUS_ASSIGNED,
                    ).order_by(desc(ServiceRequest.date_of_request)),
                    service_requests_output_schema,
                ),
                "completed_requests": lambda: (
                    ServiceRequest.query.filter_by(
                        professional_id=current_user.professional_profile.id,
                        status=REQUEST_STATUS_COMPLETED,
                    ).order_by(desc(ServiceRequest.date_of_request)),
                    service_requests_output_schema,
                ),
                "my_reviews": lambda: (
                    Review.query.join(ServiceRequest)
                    .filter(
                        ServiceRequest.professional_id
                        == current_user.professional_profile.id
                    )
                    .order_by(desc(Review.created_at)),
                    reviews_output_schema,
                ),
                "reported_reviews": lambda: (
                    Review.query.join(ServiceRequest)
                    .filter(
                        ServiceRequest.professional_id
                        == current_user.professional_profile.id,
                        Review.is_reported == True,  # noqa: E712
                    )
                    .order_by(desc(Review.created_at)),
                    reviews_output_schema,
                ),
            },
            "customer": {
                "pending_requests": lambda: (
                    ServiceRequest.query.filter_by(
                        customer_id=current_user.customer_profile.id,
                        status=REQUEST_STATUS_CREATED,
                    ).order_by(desc(ServiceRequest.date_of_request)),
                    service_requests_output_schema,
                ),
                "active_requests": lambda: (
                    ServiceRequest.query.filter_by(
                        customer_id=current_user.customer_profile.id,
                        status=REQUEST_STATUS_ASSIGNED,
                    ).order_by(desc(ServiceRequest.date_of_request)),
                    service_requests_output_schema,
                ),
                "completed_requests": lambda: (
                    ServiceRequest.query.filter_by(
                        customer_id=current_user.customer_profile.id,
                        status=REQUEST_STATUS_COMPLETED,
                    ).order_by(desc(ServiceRequest.date_of_request)),
                    service_requests_output_schema,
                ),
                "my_reviews": lambda: (
                    Review.query.join(ServiceRequest)
                    .filter(
                        ServiceRequest.customer_id == current_user.customer_profile.id
                    )
                    .order_by(desc(Review.created_at)),
                    reviews_output_schema,
                ),
                "available_services": lambda: (
                    Service.query.filter_by(is_active=True).order_by(Service.name),
                    services_output_schema,
                ),
            },
        }

        # Get available stat types for current user's role
        role_stat_types = stat_types.get(current_user.role, {})

        # Validate requested stat type
        if params["stat_type"] not in role_stat_types:
            return APIResponse.error(
                f"Invalid stat type for {current_user.role}. Available types: {', '.join(role_stat_types.keys())}",
                HTTPStatus.BAD_REQUEST,
                "InvalidStatType",
            )

        # Get query and schema for requested stat type
        query, schema = role_stat_types[params["stat_type"]]()

        # Apply date filters if applicable
        if hasattr(query.column_descriptions[0]["type"], "created_at"):
            if params.get("start_date"):
                query = query.filter(
                    query.column_descriptions[0]["type"].created_at
                    >= params["start_date"]
                )
            if params.get("end_date"):
                query = query.filter(
                    query.column_descriptions[0]["type"].created_at
                    <= params["end_date"]
                )

        # Apply pagination
        paginated = query.paginate(
            page=params["page"], per_page=params["per_page"], error_out=False
        )

        return APIResponse.success(
            data=schema.dump(paginated.items),
            message=f"Detailed {params['stat_type']} retrieved successfully",
            pagination={
                "total": paginated.total,
                "pages": paginated.pages,
                "current_page": paginated.page,
                "per_page": paginated.per_page,
                "has_next": paginated.has_next,
                "has_prev": paginated.has_prev,
            },
        )

    except ValidationError as err:
        return APIResponse.error(str(err.messages))
    except Exception as e:
        return APIResponse.error(
            f"Error retrieving detailed statistics: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )

================
File: src/routes/export.py
================
# src/routes/export.py
from flask import Blueprint, request, send_from_directory, current_app
from marshmallow import ValidationError
from http import HTTPStatus
import os

from src.tasks import generate_service_requests_csv
from src.schemas.export import export_request_schema
from src.utils.auth import token_required, role_required
from src.utils.api import APIResponse

export_bp = Blueprint("export", __name__)


@export_bp.route("/exports/service-requests", methods=["POST"])
@token_required
@role_required("professional")
def trigger_export(current_user):
    """Trigger service requests export for the professional"""
    try:
        if not current_user.professional_profile:
            return APIResponse.error(
                "Professional profile not found",
                HTTPStatus.NOT_FOUND,
                "ProfileNotFound",
            )

        if not current_user.professional_profile.is_verified:
            return APIResponse.error(
                "Account not verified", HTTPStatus.FORBIDDEN, "UnverifiedAccount"
            )

        # Validate request data
        data = export_request_schema.load(request.get_json() or {})

        # Trigger async task with professional's ID
        task = generate_service_requests_csv.delay(
            professional_id=current_user.professional_profile.id,
            start_date=data.get("start_date"),
            end_date=data.get("end_date"),
            user_email=current_user.email,
        )

        return APIResponse.success(
            data={"task_id": task.id},
            message="Export task started successfully",
            status_code=HTTPStatus.ACCEPTED,
        )

    except ValidationError as err:
        return APIResponse.error(str(err.messages))
    except Exception as e:
        return APIResponse.error(
            f"Error triggering export: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "ExportError",
        )


@export_bp.route("/exports/status/<task_id>", methods=["GET"])
@token_required
@role_required("professional")
def check_export_status(current_user, task_id):
    """Check export task status"""
    try:
        task = generate_service_requests_csv.AsyncResult(task_id)

        if task.state == "PENDING":
            response = {"state": task.state, "status": "Export task is pending"}
        elif task.state == "SUCCESS":
            # Verify the task result belongs to the requesting professional
            if (
                task.result.get("professional_id")
                != current_user.professional_profile.id
            ):
                return APIResponse.error(
                    "Unauthorized access to export",
                    HTTPStatus.FORBIDDEN,
                    "UnauthorizedAccess",
                )
            response = {
                "state": task.state,
                "status": "Export completed successfully",
                "result": task.result,
            }
        elif task.state == "FAILURE":
            response = {
                "state": task.state,
                "status": "Export failed",
                "error": str(task.info.get("error", "Unknown error")),
            }
        else:
            response = {"state": task.state, "status": "Export is in progress"}

        return APIResponse.success(data=response)

    except Exception as e:
        return APIResponse.error(
            f"Error checking export status: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "StatusCheckError",
        )


@export_bp.route("/exports/download/<filename>", methods=["GET"])
@token_required
@role_required("professional")
def download_export(current_user, filename):
    """Download exported CSV file"""
    try:
        # Verify file belongs to the professional
        if not filename.startswith(
            f"service_requests_{current_user.professional_profile.id}_"
        ):
            return APIResponse.error(
                "Unauthorized access to file",
                HTTPStatus.FORBIDDEN,
                "UnauthorizedAccess",
            )

        exports_dir = os.path.join(current_app.root_path, "static/exports")
        return send_from_directory(
            exports_dir, filename, as_attachment=True, mimetype="text/csv"
        )
    except Exception as e:
        return APIResponse.error(
            f"Error downloading file: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DownloadError",
        )

================
File: src/routes/professional.py
================
from flask import Blueprint, request, current_app
from sqlalchemy import func
from marshmallow import ValidationError
import base64
from http import HTTPStatus
import os

from src import db

from src.models import (
    User,
    ProfessionalProfile,
    ActivityLog,
    ServiceRequest,
    Service,
    Review,
)

from src.constants import (
    ActivityLogActions,
    USER_ROLE_PROFESSIONAL,
    REQUEST_STATUS_CREATED,
    REQUEST_STATUS_ASSIGNED,
)

from src.schemas.professional import (
    professional_output_schema,
    professionals_output_schema,
    professional_query_schema,
    professional_register_schema,
)
from src.schemas.user import block_user_schema
from src.schemas.request import reviews_output_schema

from src.utils.auth import token_required, role_required
from src.utils.api import APIResponse
from src.utils.file import (
    save_verification_document,
    delete_verification_document,
    UPLOAD_FOLDER,
)
from src.utils.user import check_existing_user
from src.utils.cache import cached_with_auth
from src.utils.notification import NotificationService

professional_bp = Blueprint("professional", __name__)


@professional_bp.route("/register/professional", methods=["POST"])
def register_professional():
    """Register a new professional"""
    if "verification_document" not in request.files:
        return APIResponse.error(
            "Verification document is required",
            HTTPStatus.BAD_REQUEST,
            "MissingDocument",
        )

    try:
        form_data = {
            "username": request.form.get("username"),
            "email": request.form.get("email"),
            "password": request.form.get("password"),
            "full_name": request.form.get("full_name"),
            "phone": request.form.get("phone"),
            "address": request.form.get("address"),
            "pin_code": request.form.get("pin_code"),
            "service_type_id": int(request.form.get("service_type_id")),
            "experience_years": int(request.form.get("experience_years")),
            "description": request.form.get("description"),
        }
    except (TypeError, ValueError):
        return APIResponse.error(
            "Invalid service_type_id or experience_years",
            HTTPStatus.BAD_REQUEST,
            "ValidationError",
        )

    try:
        data = professional_register_schema.load(form_data)
    except ValidationError as err:
        return APIResponse.error(str(err.messages))

    exists, error_response = check_existing_user(data["username"], data["email"])
    if exists:
        return error_response

    filename, error = save_verification_document(request.files["verification_document"])
    if error:
        return APIResponse.error(error, HTTPStatus.BAD_REQUEST, "FileUploadError")

    try:
        user = User(
            username=data["username"],
            email=data["email"],
            full_name=data["full_name"],
            phone=data["phone"],
            address=data["address"],
            pin_code=data["pin_code"],
            role=USER_ROLE_PROFESSIONAL,
            is_active=False,
        )
        user.set_password(data["password"])
        db.session.add(user)
        db.session.flush()  # Get user.id

        profile = ProfessionalProfile(
            user_id=user.id,
            service_type_id=data["service_type_id"],
            experience_years=data["experience_years"],
            description=data["description"],
            verification_documents=filename,
            is_verified=False,
        )
        db.session.add(profile)

        log = ActivityLog(
            user_id=user.id,
            action=ActivityLogActions.USER_REGISTER,
            description=f"New professional account created for {user.username}, pending verification",
        )
        db.session.add(log)
        db.session.commit()

        # Query the user again to get the relationship loaded
        user = User.query.get(user.id)
        return APIResponse.success(
            data=professional_output_schema.dump(user),
            message="Professional registered successfully. Account will be activated after verification.",
            status_code=HTTPStatus.CREATED,
        )
    except Exception as e:
        if filename:
            delete_verification_document(filename)
        return APIResponse.error(
            f"Error creating professional: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@professional_bp.route("/professionals", methods=["GET"])
@professional_bp.route("/professionals/<int:profile_id>", methods=["GET"])
@token_required
@cached_with_auth(timeout=120)
@role_required("admin", "customer")
def list_professionals(current_user, profile_id=None):
    try:
        if profile_id is not None:
            # Single professional retrieval - get the User object with joined profile
            user = (
                User.query.join(ProfessionalProfile)
                .filter(ProfessionalProfile.id == profile_id)
                .first_or_404()
            )

            # Check visibility based on role
            if current_user.role != "admin":
                if not user.professional_profile.is_verified or not user.is_active:
                    return APIResponse.error(
                        "Professional not found", HTTPStatus.NOT_FOUND, "NotFound"
                    )

            prof_data = professional_output_schema.dump(user)

            # For admin users, include verification document
            if (
                current_user.role == "admin"
                and user.professional_profile.verification_documents
            ):
                try:
                    with open(
                        os.path.join(
                            current_app.root_path,
                            UPLOAD_FOLDER,
                            user.professional_profile.verification_documents,
                        ),
                        "rb",
                    ) as f:
                        verification_doc = base64.b64encode(f.read()).decode("utf-8")
                        prof_data["verification_document_content"] = verification_doc
                except Exception as e:
                    current_app.logger.error(
                        f"Error reading verification document: {str(e)}"
                    )
                    prof_data["verification_document_content"] = None

            # Remove sensitive information for non-admin users
            elif current_user.role != "admin":
                sensitive_fields = [
                    "verification_documents",
                    "created_at",
                    "last_login",
                ]
                for field in sensitive_fields:
                    prof_data.pop(field, None)

            return APIResponse.success(
                data=prof_data,
                message="Professional retrieved successfully",
            )

        # List all professionals
        params = professional_query_schema.load(request.args)
        query = User.query.join(ProfessionalProfile)

        # Apply role-specific filters
        if current_user.role != "admin":
            query = query.filter(
                ProfessionalProfile.is_verified == True,  # noqa: E712
                User.is_active == True,  # noqa: E712
            )
        else:
            if params.get("verified") is not None:
                query = query.filter(
                    ProfessionalProfile.is_verified == params["verified"]
                )

        # Common filters
        if params.get("service_type"):
            query = query.filter(
                ProfessionalProfile.service_type_id == params["service_type"]
            )

        # Pagination
        paginated = query.paginate(
            page=params["page"], per_page=params["per_page"], error_out=False
        )

        return APIResponse.success(
            data=professionals_output_schema.dump(paginated.items),
            message="Professionals retrieved successfully",
            pagination={
                "total": paginated.total,
                "pages": paginated.pages,
                "current_page": paginated.page,
                "per_page": paginated.per_page,
                "has_next": paginated.has_next,
                "has_prev": paginated.has_prev,
            },
        )

    except ValidationError as err:
        return APIResponse.error(str(err.messages))
    except Exception as e:
        return APIResponse.error(
            f"Error retrieving professionals: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@professional_bp.route("/professionals/<int:profile_id>/verify", methods=["POST"])
@token_required
@role_required("admin")
def verify_professional(current_user, profile_id):
    """Verify a professional's profile"""
    try:
        profile = ProfessionalProfile.query.get_or_404(profile_id)
        user = User.query.get(profile.user_id)

        if profile.is_verified:
            return APIResponse.error(
                "Professional is already verified",
                HTTPStatus.CONFLICT,
                "AlreadyVerified",
            )

        profile.is_verified = True
        user.is_active = True

        log = ActivityLog(
            user_id=current_user.id,
            entity_id=user.id,
            action=ActivityLogActions.PROFESSIONAL_VERIFY,
            description=f"Verified professional profile for {user.full_name}",
        )
        db.session.add(log)
        db.session.commit()

        NotificationService.send_verification_approved(profile)

        return APIResponse.success(
            data=professional_output_schema.dump(user),
            message="Professional verified successfully",
        )
    except Exception as e:
        return APIResponse.error(
            f"Error verifying professional: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@professional_bp.route("/professionals/<int:profile_id>/block", methods=["POST"])
@token_required
@role_required("admin")
def block_professional(current_user, profile_id):
    """Block a professional's account"""
    try:
        data = block_user_schema.load(request.get_json())
        profile = ProfessionalProfile.query.get_or_404(profile_id)

        if not profile.user.is_active:
            return APIResponse.error(
                "Professional is already blocked", HTTPStatus.CONFLICT, "AlreadyBlocked"
            )

        profile.user.is_active = False

        log = ActivityLog(
            user_id=current_user.id,
            entity_id=profile.user.id,
            action=ActivityLogActions.PROFESSIONAL_BLOCK,
            description=f"Blocked professional {profile.user.full_name}. Reason: {data['reason']}",
        )
        db.session.add(log)
        db.session.commit()

        return APIResponse.success(message="Professional blocked successfully")
    except ValidationError as err:
        return APIResponse.error(str(err.messages))
    except Exception as e:
        return APIResponse.error(
            f"Error blocking professional: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@professional_bp.route("/professionals/document", methods=["PUT"])
@token_required
@role_required("professional")
def update_verification_document(current_user):
    """Update professional's verification documents"""
    try:
        # Check for active service requests first
        has_active_requests = (
            ServiceRequest.query.filter(
                ServiceRequest.professional_id == current_user.professional_profile.id,
                ServiceRequest.status.in_([REQUEST_STATUS_ASSIGNED]),
            ).first()
            is not None
        )

        if has_active_requests:
            return APIResponse.error(
                "Cannot update verification documents while having active service requests",
                HTTPStatus.CONFLICT,
                "ActiveRequestsExist",
            )

        if "verification_document" not in request.files:
            return APIResponse.error(
                "No document provided", HTTPStatus.BAD_REQUEST, "MissingDocument"
            )

        # Delete old document if it exists
        if current_user.professional_profile.verification_documents:
            delete_verification_document(
                current_user.professional_profile.verification_documents
            )

        # Save new document
        filename, error = save_verification_document(
            request.files["verification_document"]
        )
        if error:
            return APIResponse.error(error, HTTPStatus.BAD_REQUEST, "FileUploadError")

        # Update profile and set verification status
        current_user.professional_profile.verification_documents = filename
        current_user.professional_profile.is_verified = (
            False  # Reset verification status
        )
        current_user.is_active = False

        log = ActivityLog(
            user_id=current_user.id,
            action=ActivityLogActions.PROFESSIONAL_DOCUMENT_UPDATE,
            description=f"Updated verification documents for professional {current_user.username}",
        )
        db.session.add(log)
        db.session.commit()

        return APIResponse.success(
            data=professional_output_schema.dump(current_user),
            message="Verification document updated successfully. Awaiting verification.",
        )
    except Exception as e:
        # Clean up the newly uploaded file in case of error
        if "filename" in locals() and filename:
            delete_verification_document(filename)
        db.session.rollback()  # Added rollback in case of error
        return APIResponse.error(
            f"Error updating document: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@professional_bp.route("/professionals/service", methods=["PUT"])
@token_required
@role_required("professional")
def update_service_type(current_user):
    """Update professional's service type"""
    try:
        data = request.get_json()
        if not data or "service_type_id" not in data:
            return APIResponse.error(
                "Service type ID is required", HTTPStatus.BAD_REQUEST, "MissingField"
            )

        # Check for active service requests
        has_active_requests = (
            ServiceRequest.query.filter(
                ServiceRequest.professional_id == current_user.professional_profile.id,
                ServiceRequest.status.in_([REQUEST_STATUS_ASSIGNED]),
            ).first()
            is not None
        )

        if has_active_requests:
            return APIResponse.error(
                "Cannot change service type while having active requests",
                HTTPStatus.CONFLICT,
                "ActiveRequestsExist",
            )

        # Verify service exists and is active
        service = Service.query.get_or_404(data["service_type_id"])
        if not service.is_active:
            return APIResponse.error(
                "Selected service is not active",
                HTTPStatus.BAD_REQUEST,
                "InactiveService",
            )

        # Check if it's the same service type
        if current_user.professional_profile.service_type_id == service.id:
            return APIResponse.error(
                "Already assigned to this service type",
                HTTPStatus.BAD_REQUEST,
                "SameService",
            )

        current_user.professional_profile.service_type_id = service.id
        current_user.professional_profile.is_verified = (
            False  # Reset verification status
        )
        current_user.is_active = False

        log = ActivityLog(
            user_id=current_user.id,
            action=ActivityLogActions.PROFESSIONAL_SERVICE_UPDATE,
            entity_id=current_user.id,
            description=f"Updated service type for professional {current_user.username} from "
            f"{current_user.professional_profile.service_type.name} to {service.name}",
        )
        db.session.add(log)
        db.session.commit()

        return APIResponse.success(
            data=professional_output_schema.dump(current_user),
            message="Service type updated successfully. Awaiting verification.",
        )
    except Exception as e:
        db.session.rollback()
        return APIResponse.error(
            f"Error updating service type: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@professional_bp.route("/professionals/dashboard", methods=["GET"])
@token_required
@role_required("professional")
def get_professional_dashboard(current_user):
    """Get professional's dashboard statistics"""
    try:
        professional_id = current_user.professional_profile.id

        stats = {
            "total_requests": ServiceRequest.query.filter_by(
                professional_id=professional_id
            ).count(),
            "completed_requests": ServiceRequest.query.filter_by(
                professional_id=professional_id, status=REQUEST_STATUS_CREATED
            ).count(),
            "active_requests": ServiceRequest.query.filter(
                ServiceRequest.professional_id == professional_id,
                ServiceRequest.status.in_([REQUEST_STATUS_ASSIGNED]),
            ).count(),
            "average_rating": db.session.query(func.avg(Review.rating))
            .join(ServiceRequest)
            .filter(ServiceRequest.professional_id == professional_id)
            .scalar()
            or 0.0,
            "total_reviews": Review.query.join(ServiceRequest)
            .filter(ServiceRequest.professional_id == professional_id)
            .count(),
            "reported_reviews": Review.query.join(ServiceRequest)
            .filter(
                ServiceRequest.professional_id == professional_id,
                Review.is_reported == True,  # noqa: E712
            )
            .count(),
            # Additional useful statistics
            "service_type": current_user.professional_profile.service_type.name,
            "verification_status": "Verified"
            if current_user.professional_profile.is_verified
            else "Pending Verification",
        }

        return APIResponse.success(
            data=stats, message="Dashboard statistics retrieved successfully"
        )
    except Exception as e:
        return APIResponse.error(
            f"Error retrieving dashboard stats: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@professional_bp.route("/professionals/reviews", methods=["GET"])
@token_required
@role_required("professional")
def get_professional_reviews(current_user):
    """Get reviews for the logged-in professional"""
    try:
        # Apply pagination
        page = request.args.get("page", 1, type=int)
        per_page = request.args.get("per_page", 10, type=int)

        professional_id = current_user.professional_profile.id

        # Base query
        query = (
            Review.query.join(ServiceRequest)
            .filter(ServiceRequest.professional_id == professional_id)
            .order_by(Review.created_at.desc())
        )

        is_reported = request.args.get("reported", type=bool)
        if is_reported is not None:
            query = query.filter(Review.is_reported == is_reported)

        # Execute paginated query
        try:
            paginated = query.paginate(page=page, per_page=per_page, error_out=False)
        except Exception as e:
            return APIResponse.error(
                f"Pagination error: {str(e)}", HTTPStatus.BAD_REQUEST, "PaginationError"
            )

        return APIResponse.success(
            data=reviews_output_schema.dump(paginated.items),
            message="Reviews retrieved successfully",
            pagination={
                "total": paginated.total,
                "pages": paginated.pages,
                "current_page": paginated.page,
                "per_page": paginated.per_page,
                "has_next": paginated.has_next,
                "has_prev": paginated.has_prev,
            },
        )
    except Exception as e:
        return APIResponse.error(
            f"Error retrieving reviews: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )

================
File: src/routes/request.py
================
from flask import Blueprint, request
from marshmallow import ValidationError
from http import HTTPStatus
from datetime import datetime, timedelta

from src import db

from src.models import (
    ServiceRequest,
    CustomerProfile,
    ProfessionalProfile,
    Review,
    Service,
    ActivityLog,
)

from src.constants import (
    ActivityLogActions,
    REQUEST_STATUS_CREATED,
    REQUEST_STATUS_ASSIGNED,
    REQUEST_STATUS_COMPLETED,
)

from src.schemas.request import (
    service_request_input_schema,
    service_request_output_schema,
    service_requests_output_schema,
    review_output_schema,
    ReviewInputSchema,
)

from src.utils.auth import token_required, role_required
from src.utils.api import APIResponse
from src.utils.request import check_booking_availability
from src.utils.notification import NotificationService

request_bp = Blueprint("request", __name__)


@request_bp.route("/requests", methods=["POST"])
@token_required
@role_required("customer")
def create_service_request(current_user):
    """Create a new service request"""
    try:
        data = service_request_input_schema.load(request.get_json())

        # Verify service exists and is active
        service = Service.query.get_or_404(data["service_id"])
        if not service.is_active:
            return APIResponse.error(
                "Selected service is not currently available",
                HTTPStatus.BAD_REQUEST,
                "InactiveService",
            )

        # Check if service can be completed by 6 PM
        service_end_time = data["preferred_time"] + timedelta(
            minutes=service.estimated_time
        )
        end_time_limit = datetime.combine(
            data["preferred_time"].date(), datetime.strptime("18:00", "%H:%M").time()
        )
        if service_end_time > end_time_limit:
            return APIResponse.error(
                "Service cannot be completed by 6 PM with the selected start time",
                HTTPStatus.BAD_REQUEST,
                "InvalidTimeSlot",
            )

        # Verify customer profile exists
        if not current_user.customer_profile:
            return APIResponse.error(
                "Customer profile not found", HTTPStatus.NOT_FOUND, "ProfileNotFound"
            )

        # Check if customer has any pending payments (if implementing payments)
        # if has_pending_payments(current_user.customer_profile.id):
        #     return APIResponse.error(
        #         "Cannot create new request with pending payments",
        #         HTTPStatus.FORBIDDEN,
        #         "PendingPayments"
        #     )

        # Create service request
        service_request = ServiceRequest(
            service_id=data["service_id"],
            customer_id=current_user.customer_profile.id,
            preferred_time=data["preferred_time"],
            description=data.get("description", ""),
            status=REQUEST_STATUS_CREATED,
            date_of_request=datetime.utcnow(),
        )

        db.session.add(service_request)
        db.session.flush()

        # Create activity log
        log = ActivityLog(
            user_id=current_user.id,
            action=ActivityLogActions.REQUEST_CREATE,
            entity_id=service_request.id,
            description=f"Created service request for {service.name}",
        )
        db.session.add(log)
        db.session.commit()

        return APIResponse.success(
            data=service_request_output_schema.dump(service_request),
            message="Service request created successfully",
            status_code=HTTPStatus.CREATED,
        )
    except ValidationError as err:
        return APIResponse.error(
            str(err.messages), HTTPStatus.BAD_REQUEST, "ValidationError"
        )
    except Exception as e:
        db.session.rollback()
        return APIResponse.error(
            f"Error creating service request: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@request_bp.route("/customer/requests", methods=["GET"])
@token_required
@role_required("customer")
def list_customer_requests(current_user):
    """List all service requests for the current customer"""
    try:
        customer_profile = CustomerProfile.query.filter_by(
            user_id=current_user.id
        ).first()
        if not customer_profile:
            return APIResponse.error(
                "Customer profile not found", HTTPStatus.NOT_FOUND, "ProfileNotFound"
            )

        # Get query parameters
        status = request.args.get("status")
        page = request.args.get("page", 1, type=int)
        per_page = request.args.get("per_page", 10, type=int)

        # Build query
        query = ServiceRequest.query.filter_by(customer_id=customer_profile.id)
        if status:
            query = query.filter_by(status=status)

        # Apply pagination
        try:
            paginated = query.order_by(ServiceRequest.date_of_request.desc()).paginate(
                page=page, per_page=per_page, error_out=False
            )
        except Exception as e:
            return APIResponse.error(
                f"Pagination error: {str(e)}", HTTPStatus.BAD_REQUEST, "PaginationError"
            )

        return APIResponse.success(
            data=service_requests_output_schema.dump(paginated.items),
            message="Requests retrieved successfully",
            pagination={
                "total": paginated.total,
                "pages": paginated.pages,
                "current_page": paginated.page,
                "per_page": paginated.per_page,
                "has_next": paginated.has_next,
                "has_prev": paginated.has_prev,
            },
        )
    except Exception as e:
        return APIResponse.error(
            f"Error retrieving requests: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@request_bp.route("/requests/<int:request_id>/cancel", methods=["POST"])
@token_required
@role_required("customer")
def cancel_request(current_user, request_id):
    """Cancel a service request by deleting it"""
    try:
        customer_profile = CustomerProfile.query.filter_by(
            user_id=current_user.id
        ).first()
        if not customer_profile:
            return APIResponse.error(
                "Customer profile not found", HTTPStatus.NOT_FOUND, "ProfileNotFound"
            )

        service_request = ServiceRequest.query.get_or_404(request_id)

        if service_request.customer_id != customer_profile.id:
            return APIResponse.error(
                "Cannot access others requests",
                HTTPStatus.FORBIDDEN,
                "UnauthorizedAccess",
            )

        # Only allow cancellation of created or assigned requests
        if service_request.status not in [REQUEST_STATUS_CREATED]:
            return APIResponse.error(
                "Cannot cancel completed or assigned requests",
                HTTPStatus.BAD_REQUEST,
                "InvalidStatus",
            )

        # Create activity log before deletion
        log = ActivityLog(
            user_id=current_user.id,
            action=ActivityLogActions.REQUEST_CANCEL,
            entity_id=request_id,
            description=(f"Cancelled service request {request_id}"),
        )
        db.session.add(log)

        # Delete the service request
        db.session.delete(service_request)
        db.session.commit()

        return APIResponse.success(
            message="Service request cancelled successfully",
            data={},
        )
    except Exception as e:
        db.session.rollback()
        return APIResponse.error(
            f"Error cancelling request: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@request_bp.route("/requests/<int:request_id>/review", methods=["POST"])
@token_required
@role_required("customer")
def submit_review(current_user, request_id):
    """Submit a review for a completed service request"""
    try:
        data = ReviewInputSchema().load(request.get_json())
    except ValidationError as err:
        return APIResponse.error(str(err.messages))

    try:
        customer_profile = CustomerProfile.query.filter_by(
            user_id=current_user.id
        ).first()
        if not customer_profile:
            return APIResponse.error(
                "Customer profile not found", HTTPStatus.NOT_FOUND, "ProfileNotFound"
            )

        service_request = ServiceRequest.query.get_or_404(request_id)

        if service_request.customer_id != customer_profile.id:
            return APIResponse.error(
                "Cannot access others requests",
                HTTPStatus.FORBIDDEN,
                "UnauthorizedAccess",
            )

        if service_request.status != REQUEST_STATUS_COMPLETED:
            return APIResponse.error(
                "Can only review completed services",
                HTTPStatus.BAD_REQUEST,
                "InvalidStatus",
            )

        if Review.query.filter_by(service_request_id=request_id).first():
            return APIResponse.error(
                "Review already exists for this service request",
                HTTPStatus.CONFLICT,
                "DuplicateReview",
            )

        review = Review(
            service_request_id=request_id,
            rating=data["rating"],
            comment=data.get("comment"),
        )
        db.session.add(review)

        # Update professional's average rating
        professional = service_request.professional
        reviews = (
            Review.query.join(ServiceRequest)
            .filter(ServiceRequest.professional_id == professional.id)
            .all()
        )
        total_ratings = sum(r.rating for r in reviews) + review.rating
        professional.average_rating = round(total_ratings / (len(reviews) + 1), 1)

        log = ActivityLog(
            user_id=current_user.id,
            action=ActivityLogActions.REVIEW_SUBMIT,
            entity_id=review.id,
            description=f"Submitted review for service request {request_id}",
        )
        db.session.add(log)
        db.session.commit()

        return APIResponse.success(
            data=review_output_schema.dump(review),
            message="Review submitted successfully",
            status_code=HTTPStatus.CREATED,
        )
    except Exception as e:
        return APIResponse.error(
            f"Error submitting review: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@request_bp.route("/professional/requests", methods=["GET"])
@token_required
@role_required("professional")
def list_professional_requests(current_user):
    """List service requests based on type (available/ongoing/completed/all)"""
    try:
        professional = ProfessionalProfile.query.filter_by(
            user_id=current_user.id
        ).first()
        if not professional:
            return APIResponse.error(
                "Professional profile not found",
                HTTPStatus.NOT_FOUND,
                "ProfileNotFound",
            )

        if not professional.is_verified:
            return APIResponse.error(
                "Account not verified yet", HTTPStatus.FORBIDDEN, "UnverifiedAccount"
            )

        # Get query parameters
        request_type = request.args.get("type", "all").lower()
        page = request.args.get("page", 1, type=int)
        per_page = request.args.get("per_page", 10, type=int)

        # Build base query
        if request_type == "available":
            # Available requests - matching service type and unassigned
            query = ServiceRequest.query.filter_by(
                service_id=professional.service_type_id, status=REQUEST_STATUS_CREATED
            ).order_by(ServiceRequest.preferred_time.asc())

        elif request_type == "ongoing":
            # Ongoing requests - assigned to this professional
            query = ServiceRequest.query.filter_by(
                professional_id=professional.id, status=REQUEST_STATUS_ASSIGNED
            ).order_by(ServiceRequest.date_of_assignment.desc())

        elif request_type == "completed":
            # Completed requests by this professional
            query = ServiceRequest.query.filter_by(
                professional_id=professional.id, status=REQUEST_STATUS_COMPLETED
            ).order_by(ServiceRequest.date_of_completion.desc())

        elif request_type == "all":
            # All requests - either available for their service type or assigned/completed by them
            query = ServiceRequest.query.filter(
                (
                    (ServiceRequest.service_id == professional.service_type_id)
                    & (ServiceRequest.status == REQUEST_STATUS_CREATED)
                )
                | (ServiceRequest.professional_id == professional.id)
            ).order_by(ServiceRequest.date_of_request.desc())

        else:
            return APIResponse.error(
                "Invalid request type. Must be one of: available, ongoing, completed, all",
                HTTPStatus.BAD_REQUEST,
                "InvalidRequestType",
            )

        # Apply pagination
        try:
            paginated = query.paginate(page=page, per_page=per_page, error_out=False)
        except Exception as e:
            return APIResponse.error(
                f"Pagination error: {str(e)}", HTTPStatus.BAD_REQUEST, "PaginationError"
            )

        return APIResponse.success(
            data=service_requests_output_schema.dump(paginated.items),
            message=f"Requests retrieved successfully (type: {request_type})",
            pagination={
                "total": paginated.total,
                "pages": paginated.pages,
                "current_page": paginated.page,
                "per_page": paginated.per_page,
                "has_next": paginated.has_next,
                "has_prev": paginated.has_prev,
            },
        )
    except Exception as e:
        return APIResponse.error(
            f"Error retrieving requests: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@request_bp.route("/requests/<int:request_id>/accept", methods=["POST"])
@token_required
@role_required("professional")
def accept_request(current_user, request_id):
    """Accept a service request"""
    try:
        professional = ProfessionalProfile.query.filter_by(
            user_id=current_user.id
        ).first()
        if not professional:
            return APIResponse.error(
                "Professional profile not found",
                HTTPStatus.NOT_FOUND,
                "ProfileNotFound",
            )

        if not professional.is_verified:
            return APIResponse.error(
                "Account not verified yet", HTTPStatus.FORBIDDEN, "UnverifiedAccount"
            )

        service_request = ServiceRequest.query.get_or_404(request_id)

        if service_request.status != REQUEST_STATUS_CREATED:
            return APIResponse.error(
                "Request is not available for acceptance",
                HTTPStatus.BAD_REQUEST,
                "InvalidStatus",
            )

        if service_request.service_id != professional.service_type_id:
            return APIResponse.error(
                "Service type mismatch", HTTPStatus.BAD_REQUEST, "ServiceMismatch"
            )

        # Get the service estimated time value
        service = Service.query.get(service_request.service_id)
        estimated_time = service.estimated_time if service else None

        if estimated_time is None:
            return APIResponse.error(
                "Invalid service configuration",
                HTTPStatus.INTERNAL_SERVER_ERROR,
                "ServiceError",
            )

        # Check for booking availability using the integer value of estimated_time
        is_available, error_message = check_booking_availability(
            professional.id,
            service_request.preferred_time,
            estimated_time,  # Now passing the integer value
        )

        if not is_available:
            return APIResponse.error(
                error_message, HTTPStatus.CONFLICT, "BookingOverlap"
            )

        service_request.professional_id = professional.id
        service_request.status = REQUEST_STATUS_ASSIGNED
        service_request.date_of_assignment = datetime.utcnow()

        log = ActivityLog(
            user_id=current_user.id,
            action=ActivityLogActions.REQUEST_ASSIGN,
            entity_id=request_id,
            description=f"Accepted service request {request_id}",
        )
        db.session.add(log)
        db.session.commit()

        NotificationService.send_service_request_notification(service_request)

        return APIResponse.success(
            data=service_request_output_schema.dump(service_request),
            message="Service request accepted successfully",
        )
    except Exception as e:
        db.session.rollback()  # Added rollback in case of error
        return APIResponse.error(
            f"Error accepting request: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@request_bp.route("/requests/<int:request_id>/complete", methods=["POST"])
@token_required
@role_required("customer", "professional")
def complete_service(current_user, request_id):
    """Mark a service request as completed with permissions for both customer and professional"""
    try:
        # Get the service request
        service_request = ServiceRequest.query.get_or_404(request_id)

        # Verify authorization based on role
        if current_user.role == "customer":
            if (
                not current_user.customer_profile
                or service_request.customer_id != current_user.customer_profile.id
            ):
                return APIResponse.error(
                    "Cannot access others requests",
                    HTTPStatus.FORBIDDEN,
                    "UnauthorizedAccess",
                )
        else:  # Professional
            if (
                not current_user.professional_profile
                or service_request.professional_id
                != current_user.professional_profile.id
            ):
                return APIResponse.error(
                    "Cannot access others requests",
                    HTTPStatus.FORBIDDEN,
                    "UnauthorizedAccess",
                )

        # Validate request status
        if service_request.status != REQUEST_STATUS_ASSIGNED:
            return APIResponse.error(
                "Cannot complete already completed/unassigned service",
                HTTPStatus.BAD_REQUEST,
                "InvalidStatus",
            )

        # Check if enough time has passed based on estimated completion time
        estimated_completion_time = service_request.preferred_time + timedelta(
            minutes=service_request.service.estimated_time
        )
        current_time = datetime.utcnow()

        if current_time < estimated_completion_time:
            remaining_minutes = int(
                (estimated_completion_time - current_time).total_seconds() / 60
            )
            return APIResponse.error(
                f"Service cannot be completed yet. {remaining_minutes} minutes remaining based on estimated duration.",
                HTTPStatus.BAD_REQUEST,
                "EarlyCompletion",
            )

        # Validate request body
        data = request.get_json()
        if not data or not data.get("remarks"):
            return APIResponse.error(
                "Remarks are required for completion",
                HTTPStatus.BAD_REQUEST,
                "MissingRemarks",
            )

        # Update service request
        service_request.status = REQUEST_STATUS_COMPLETED
        service_request.date_of_completion = current_time
        service_request.remarks = data["remarks"]

        # Create activity log
        log = ActivityLog(
            user_id=current_user.id,
            action=ActivityLogActions.REQUEST_COMPLETE,
            entity_id=request_id,
            description=f"Service request {request_id} marked as completed by {current_user.role}",
        )
        db.session.add(log)
        db.session.commit()

        return APIResponse.success(
            data=service_request_output_schema.dump(service_request),
            message="Service marked as completed successfully",
        )
    except Exception as e:
        db.session.rollback()
        return APIResponse.error(
            f"Error completing service: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@request_bp.route("/requests/<int:request_id>", methods=["PUT"])
@token_required
@role_required("customer")
def edit_service_request(current_user, request_id):
    """Edit an existing service request"""
    try:
        # Validate request body
        data = service_request_input_schema.load(request.get_json())

        # Verify customer profile and request
        customer_profile = CustomerProfile.query.filter_by(
            user_id=current_user.id
        ).first()
        if not customer_profile:
            return APIResponse.error(
                "Customer profile not found", HTTPStatus.NOT_FOUND, "ProfileNotFound"
            )

        service_request = ServiceRequest.query.get_or_404(request_id)

        # Check ownership
        if service_request.customer_id != customer_profile.id:
            return APIResponse.error(
                "Cannot access others requests",
                HTTPStatus.FORBIDDEN,
                "UnauthorizedAccess",
            )

        # Only allow editing of unassigned requests
        if service_request.status != REQUEST_STATUS_CREATED:
            return APIResponse.error(
                "Cannot edit requests that have been assigned or completed",
                HTTPStatus.BAD_REQUEST,
                "InvalidStatus",
            )

        # Verify service exists and is active
        service = Service.query.get_or_404(data["service_id"])
        if not service.is_active:
            return APIResponse.error(
                "Selected service is not currently available",
                HTTPStatus.BAD_REQUEST,
                "InactiveService",
            )

        # Check if service can be completed by 6 PM
        service_end_time = data["preferred_time"] + timedelta(
            minutes=service.estimated_time
        )
        end_time_limit = datetime.combine(
            data["preferred_time"].date(), datetime.strptime("18:00", "%H:%M").time()
        )
        if service_end_time > end_time_limit:
            return APIResponse.error(
                "Service cannot be completed by 6 PM with the selected start time",
                HTTPStatus.BAD_REQUEST,
                "InvalidTimeSlot",
            )

        # Update request fields
        service_request.service_id = data["service_id"]
        service_request.preferred_time = data["preferred_time"]
        service_request.description = data.get(
            "description", service_request.description
        )

        # Create activity log
        log = ActivityLog(
            user_id=current_user.id,
            action=ActivityLogActions.REQUEST_UPDATE,
            entity_id=request_id,
            description=f"Updated service request {request_id} details",
        )
        db.session.add(log)
        db.session.commit()

        return APIResponse.success(
            data=service_request_output_schema.dump(service_request),
            message="Service request updated successfully",
        )
    except ValidationError as err:
        return APIResponse.error(
            str(err.messages), HTTPStatus.BAD_REQUEST, "ValidationError"
        )
    except Exception as e:
        db.session.rollback()
        return APIResponse.error(
            f"Error updating service request: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )

================
File: src/routes/service.py
================
from flask import Blueprint, request, current_app
from marshmallow import ValidationError
from http import HTTPStatus
import jwt

from src import db

from src.models import Service, ProfessionalProfile, ActivityLog, User

from src.constants import ActivityLogActions

from src.schemas.service import (
    service_output_schema,
    services_output_schema,
    service_input_schema,
    service_query_schema,
    service_update_schema,
)


from src.utils.auth import token_required, role_required
from src.utils.api import APIResponse
from src.utils.cache import cached_with_auth, cache_invalidate


service_bp = Blueprint("service", __name__)


@service_bp.route("/services", methods=["POST"])
@token_required
@role_required("admin")
@cache_invalidate("view/services*")
def create_service(current_user):
    """Create a new service"""
    try:
        data = service_input_schema.load(request.get_json())
    except ValidationError as err:
        return APIResponse.error(str(err.messages))

    # Check if service name already exists
    if Service.query.filter_by(name=data["name"]).first():
        return APIResponse.error(
            "Service with this name already exists",
            HTTPStatus.CONFLICT,
            "DuplicateService",
        )

    try:
        service = Service(
            name=data["name"],
            description=data["description"],
            base_price=data["base_price"],
            estimated_time=data["estimated_time"],
            is_active=True,
        )
        db.session.add(service)
        db.session.flush()

        log = ActivityLog(
            user_id=current_user.id,
            entity_id=service.id,
            action=ActivityLogActions.SERVICE_CREATE,
            description=f"Created new service: {service.name}",
        )
        db.session.add(log)
        db.session.commit()

        return APIResponse.success(
            data=service_output_schema.dump(service),
            message="Service created successfully",
            status_code=HTTPStatus.CREATED,
        )
    except Exception as e:
        return APIResponse.error(
            f"Error creating service: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@service_bp.route("/services", methods=["GET"])
@service_bp.route("/services/<int:service_id>", methods=["GET"])
@cached_with_auth(timeout=300)
def list_services(service_id=None):
    """List all services or get a specific service"""
    try:
        # Get authentication token if present
        token = None
        if "Authorization" in request.headers:
            auth_header = request.headers["Authorization"]
            try:
                token = auth_header.split(" ")[1]
            except IndexError:
                token = None

        # Check if user is admin
        is_admin = False
        if token:
            try:
                data = jwt.decode(
                    current_app.config["SECRET_KEY"], algorithms=["HS256"]
                )
                current_user = User.query.get(data["user_id"])
                is_admin = current_user and current_user.role == "admin"
            except (jwt.InvalidTokenError, Exception):
                pass

        if service_id is not None:
            # Single service retrieval
            service = Service.query.get_or_404(service_id)

            # If not admin, only return active services
            if not is_admin and not service.is_active:
                return APIResponse.error(
                    "Service not found", HTTPStatus.NOT_FOUND, "NotFound"
                )

            return APIResponse.success(
                data=service_output_schema.dump(service),
                message="Service retrieved successfully",
            )

        # List services with filtering and pagination
        params = service_query_schema.load(request.args)
        query = Service.query

        # Non-admin users can only see active services
        if not is_admin:
            query = query.filter_by(is_active=True)
        elif params.get("is_active") is not None:
            query = query.filter_by(is_active=params["is_active"])

        # Apply pagination
        paginated = query.paginate(
            page=params["page"], per_page=params["per_page"], error_out=False
        )

        return APIResponse.success(
            data=services_output_schema.dump(paginated.items),
            message="Services retrieved successfully",
            pagination={
                "total": paginated.total,
                "pages": paginated.pages,
                "current_page": paginated.page,
                "per_page": paginated.per_page,
                "has_next": paginated.has_next,
                "has_prev": paginated.has_prev,
            },
        )

    except ValidationError as err:
        return APIResponse.error(str(err.messages))
    except Exception as e:
        return APIResponse.error(
            f"Error retrieving services: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@service_bp.route("/services/<int:service_id>", methods=["PUT"])
@token_required
@cache_invalidate("view/services*")
@role_required("admin")
def update_service(current_user, service_id):
    """Update an existing service"""
    try:
        service = Service.query.get_or_404(service_id)
        data = service_update_schema.load(request.get_json(), partial=True)

        # Check name uniqueness if name is being updated
        if "name" in data and data["name"] != service.name:
            if Service.query.filter_by(name=data["name"]).first():
                return APIResponse.error(
                    "Service with this name already exists",
                    HTTPStatus.CONFLICT,
                    "DuplicateService",
                )

        # Update fields
        for key, value in data.items():
            setattr(service, key, value)

        log = ActivityLog(
            user_id=current_user.id,
            action=ActivityLogActions.SERVICE_UPDATE,
            entity_id=service_id,
            description=f"Updated service: {service.name}",
        )
        db.session.add(log)
        db.session.commit()

        return APIResponse.success(
            data=service_output_schema.dump(service),
            message="Service updated successfully",
        )
    except ValidationError as err:
        return APIResponse.error(str(err.messages))
    except Exception as e:
        return APIResponse.error(
            f"Error updating service: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@service_bp.route("/services/<int:service_id>/toggle", methods=["POST"])
@token_required
@role_required("admin")
def toggle_service(current_user, service_id):
    """Toggle service active status"""
    try:
        service = Service.query.get_or_404(service_id)

        # If deactivating, check for active professionals
        if service.is_active:
            active_professionals = (
                ProfessionalProfile.query.join(User)
                .filter(
                    ProfessionalProfile.service_type_id == service_id,
                    ProfessionalProfile.is_verified == True,  # noqa: E712
                    User.is_active == True,  # noqa: E712
                )
                .count()
            )

            if active_professionals > 0:
                return APIResponse.error(
                    "Cannot deactivate service with active professionals",
                    HTTPStatus.CONFLICT,
                    "ActiveProfessionalsExist",
                )

        # Toggle status
        service.is_active = not service.is_active
        action = (
            ActivityLogActions.SERVICE_DELETE
            if not service.is_active
            else ActivityLogActions.SERVICE_RESTORE
        )

        log = ActivityLog(
            user_id=current_user.id,
            action=action,
            entity_id=service_id,
            description=f"{'Deactivated' if not service.is_active else 'Activated'} service: {service.name}",
        )
        db.session.add(log)
        db.session.commit()

        message = (
            "Service deactivated successfully"
            if not service.is_active
            else "Service activated successfully"
        )
        return APIResponse.success(
            data=service_output_schema.dump(service), message=message
        )
    except Exception as e:
        return APIResponse.error(
            f"Error toggling service status: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@service_bp.route("/services/<int:service_id>", methods=["DELETE"])
@token_required
@role_required("admin")
def delete_service(current_user, service_id):
    """Permanently delete a service that has never been used"""
    try:
        service = Service.query.get_or_404(service_id)

        # Check if service has ever been assigned to any professional
        has_professionals = (
            ProfessionalProfile.query.filter_by(service_type_id=service_id).first()
            is not None
        )

        if has_professionals:
            return APIResponse.error(
                "Cannot delete service that has been assigned to professionals. Use deactivate instead.",
                HTTPStatus.CONFLICT,
                "ServiceInUse",
            )

        log = ActivityLog(
            user_id=current_user.id,
            action=ActivityLogActions.SERVICE_DELETE,
            entity_id=service_id,
            description=f"Permanently deleted service: {service.name}",
        )
        db.session.add(log)

        db.session.delete(service)
        db.session.commit()

        return APIResponse.success(
            message="Service permanently deleted successfully",
            status_code=HTTPStatus.OK,
        )
    except Exception as e:
        return APIResponse.error(
            f"Error deleting service: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )

================
File: src/routes/user.py
================
from flask import Blueprint, request
from marshmallow import ValidationError
from http import HTTPStatus

from src import db

from src.models import (
    User,
    ServiceRequest,
    ActivityLog,
)

from src.constants import (
    USER_ROLE_PROFESSIONAL,
    USER_ROLE_CUSTOMER,
    ActivityLogActions,
    REQUEST_STATUS_ASSIGNED,
    REQUEST_STATUS_CREATED,
)

from src.schemas.user import (
    password_update_schema,
    delete_account_schema,
    admin_output_schema,
)
from src.schemas.customer import (
    customer_output_schema,
    customer_update_schema,
)
from src.schemas.professional import (
    professional_output_schema,
    professional_update_schema,
)


from src.utils.auth import token_required, APIResponse, role_required
from src.utils.file import delete_verification_document

user_bp = Blueprint("user", __name__)


@user_bp.route("/profile", methods=["GET"])
@token_required
def get_profile(current_user):
    """Get current user's profile"""
    try:
        if current_user.role == USER_ROLE_PROFESSIONAL:
            schema = professional_output_schema
            message = "Professional profile retrieved successfully"
        elif current_user.role == USER_ROLE_CUSTOMER:
            schema = customer_output_schema
            message = f"{current_user.role.capitalize()} profile retrieved successfully"
        else:
            schema = admin_output_schema
            message = f"{current_user.role.capitalize()} profile retrieved successfully"

        return APIResponse.success(data=schema.dump(current_user), message=message)
    except Exception as e:
        return APIResponse.error(
            f"Error retrieving profile: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@user_bp.route("/change-password", methods=["POST"])
@token_required
@role_required("customer", "professional")
def change_password(current_user):
    """Change user's password"""
    try:
        data = password_update_schema.load(request.get_json())
    except ValidationError as err:
        return APIResponse.error(str(err.messages))

    if not current_user.check_password(data["old_password"]):
        return APIResponse.error(
            "Current password is incorrect", HTTPStatus.UNAUTHORIZED, "InvalidPassword"
        )

    try:
        current_user.set_password(data["new_password"])

        log = ActivityLog(
            user_id=current_user.id,
            action=ActivityLogActions.USER_PASSWORD_CHANGE,
            description=f"Password changed for user {current_user.username}",
        )
        db.session.add(log)
        db.session.commit()

        return APIResponse.success(message="Password changed successfully")
    except Exception as e:
        return APIResponse.error(
            f"Error changing password: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@user_bp.route("/profile", methods=["PUT"])
@token_required
@role_required("customer", "professional")
def update_profile(current_user):
    """Update user's profile information"""
    try:
        schema = (
            professional_update_schema
            if current_user.role == USER_ROLE_PROFESSIONAL
            else customer_update_schema
        )
        data = schema.load(request.get_json())
    except ValidationError as err:
        return APIResponse.error(str(err.messages))

    try:
        if "email" in data and data["email"] != current_user.email:
            if User.query.filter_by(email=data["email"]).first():
                return APIResponse.error(
                    "Email already in use", HTTPStatus.CONFLICT, "DuplicateEmail"
                )
            current_user.email = data["email"]

        for field in ["full_name", "phone", "address", "pin_code"]:
            if field in data:
                setattr(current_user, field, data[field])

        if current_user.role == USER_ROLE_PROFESSIONAL and "description" in data:
            current_user.professional_profile.description = data["description"]

        log = ActivityLog(
            user_id=current_user.id,
            action=ActivityLogActions.USER_PROFILE_UPDATE,
            description=f"Profile updated for user {current_user.username}",
        )
        db.session.add(log)
        db.session.commit()

        schema = (
            professional_output_schema
            if current_user.role == USER_ROLE_PROFESSIONAL
            else customer_output_schema
        )
        return APIResponse.success(
            data=schema.dump(current_user), message="Profile updated successfully"
        )
    except Exception as e:
        return APIResponse.error(
            f"Error updating profile: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )


@user_bp.route("/delete-account", methods=["DELETE"])
@token_required
@role_required("customer", "professional")
def delete_account(current_user):
    """Hard delete user account"""
    try:
        data = delete_account_schema.load(request.get_json())
    except ValidationError as err:
        return APIResponse.error(str(err.messages))

    if not current_user.check_password(data["password"]):
        return APIResponse.error(
            "Incorrect password", HTTPStatus.UNAUTHORIZED, "InvalidPassword"
        )

    try:
        # Check for active requests based on user role
        if current_user.role == USER_ROLE_PROFESSIONAL:
            has_active_requests = (
                ServiceRequest.query.filter(
                    ServiceRequest.professional_id
                    == current_user.professional_profile.id,
                    ServiceRequest.status.in_([REQUEST_STATUS_ASSIGNED]),
                ).first()
                is not None
            )
            verification_doc = current_user.professional_profile.verification_documents
        else:
            has_active_requests = (
                ServiceRequest.query.filter(
                    ServiceRequest.customer_id == current_user.customer_profile.id,
                    ServiceRequest.status.in_(
                        [REQUEST_STATUS_CREATED, REQUEST_STATUS_ASSIGNED]
                    ),
                ).first()
                is not None
            )

        if has_active_requests:
            return APIResponse.error(
                "Cannot delete account while having active service requests",
                HTTPStatus.CONFLICT,
                "ActiveRequestsExist",
            )

        log = ActivityLog(
            user_id=None,  # Since user will be deleted
            action=ActivityLogActions.USER_DELETE,
            description=f"Account deleted for user {current_user.username} (role: {current_user.role})",
        )
        db.session.add(log)

        if current_user.role == USER_ROLE_PROFESSIONAL and verification_doc:
            delete_verification_document(verification_doc)

        db.session.delete(current_user)
        db.session.commit()

        return APIResponse.success(
            message="Account successfully deleted", status_code=HTTPStatus.OK
        )
    except Exception as e:
        return APIResponse.error(
            f"Error deleting account: {str(e)}",
            HTTPStatus.INTERNAL_SERVER_ERROR,
            "DatabaseError",
        )

================
File: src/schemas/auth.py
================
from marshmallow import fields, Schema


class LoginSchema(Schema):
    username = fields.Str(required=True)
    password = fields.Str(required=True)


class TokenSchema(Schema):
    token = fields.Str(required=True)


login_schema = LoginSchema()
token_schema = TokenSchema()

================
File: src/schemas/base.py
================
import re
from marshmallow import fields, Schema, validate, validates, ValidationError


class BaseSchema(Schema):
    """Base schema with common validation methods"""

    @staticmethod
    def validate_phone(value: str) -> None:
        if not re.match(r"^[1-9]\d{9}$", value):
            raise ValidationError("Phone number must be 10 digits and not start with 0")

    @staticmethod
    def validate_password(value: str) -> None:
        if len(value) < 8:
            raise ValidationError("Password must be at least 8 characters")
        if not re.search(r"[A-Z]", value):
            raise ValidationError("Password must contain an uppercase letter")
        if not re.search(r"[a-z]", value):
            raise ValidationError("Password must contain a lowercase letter")
        if not re.search(r"\d", value):
            raise ValidationError("Password must contain a number")
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', value):
            raise ValidationError("Password must contain a special character")

    @staticmethod
    def validate_pincode(value: str) -> None:
        if not re.match(r"^[1-9][0-9]{5}$", value):
            raise ValidationError("PIN code must be 6 digits and not start with 0")


class BaseUserSchema(Schema):
    """Base schema for user data"""

    id = fields.Int(dump_only=True)
    username = fields.Str(required=True)
    email = fields.Str(required=True)
    full_name = fields.Str(required=True)
    phone = fields.Str(required=True)
    address = fields.Str(required=True)
    pin_code = fields.Str(required=True)
    role = fields.Str(dump_only=True)
    is_active = fields.Bool(dump_only=True)
    created_at = fields.DateTime(dump_only=True)
    last_login = fields.DateTime(dump_only=True)


class BaseUserInputSchema(BaseSchema):
    username = fields.Str(
        required=True,
        validate=[
            validate.Length(min=4, max=20),
            validate.Regexp(r"^[a-zA-Z0-9_.-]+$"),
        ],
    )
    email = fields.Email(required=True)
    password = fields.Str(required=True)
    full_name = fields.Str(
        required=True,
        validate=[
            validate.Length(min=4, max=100),
            validate.Regexp(r"^[a-zA-Z\s.-]+$"),
        ],
    )
    phone = fields.Str(required=True)
    address = fields.Str(required=True, validate=validate.Length(min=5, max=200))
    pin_code = fields.Str(required=True)

    @validates("phone")
    def validate_phone_field(self, value):
        self.validate_phone(value)

    @validates("password")
    def validate_password_field(self, value):
        self.validate_password(value)

    @validates("pin_code")
    def validate_pincode_field(self, value):
        self.validate_pincode(value)


class BaseProfileUpdateSchema(BaseSchema):
    """Base schema for profile updates"""

    email = fields.Email()
    full_name = fields.Str(validate=validate.Length(min=4, max=100))
    phone = fields.Str()
    address = fields.Str(validate=validate.Length(min=5, max=200))
    pin_code = fields.Str()

    @validates("phone")
    def validate_phone_field(self, value):
        self.validate_phone(value)

    @validates("pin_code")
    def validate_pincode_field(self, value):
        self.validate_pincode(value)

================
File: src/schemas/customer.py
================
from marshmallow import fields, Schema

from src.schemas.base import (
    BaseUserSchema,
    BaseProfileUpdateSchema,
    BaseUserInputSchema,
)


class CustomerRegisterSchema(BaseUserInputSchema):
    pass


class CustomerUpdateSchema(BaseProfileUpdateSchema):
    """Schema for customer profile updates"""

    pass


class CustomerOutputSchema(BaseUserSchema):
    """Customer output schema - includes all user fields"""

    customer_id = fields.Int(attribute="customer_profile.id", dump_only=True)


class CustomerQuerySchema(Schema):
    """Schema for validating customer list query parameters"""

    active = fields.Bool(required=False)
    page = fields.Int(required=False, missing=1)
    per_page = fields.Int(required=False, missing=10)


customer_output_schema = CustomerOutputSchema()
customers_output_schema = CustomerOutputSchema(many=True)
customer_update_schema = CustomerUpdateSchema()
customer_query_schema = CustomerQuerySchema()
customer_register_schema = CustomerRegisterSchema()

================
File: src/schemas/dashboard.py
================
from marshmallow import fields, Schema, validate


class ActivityLogQuerySchema(Schema):
    """Schema for activity log query parameters"""

    action = fields.Str(required=False)
    user_id = fields.Int(required=False)
    start_date = fields.DateTime(required=False)
    end_date = fields.DateTime(required=False)
    page = fields.Int(required=False, missing=1)
    per_page = fields.Int(required=False, missing=10)


class ActivityLogSchema(Schema):
    """Schema for activity log output"""

    id = fields.Int(dump_only=True)
    user_id = fields.Int(allow_none=True)
    entity_id = fields.Int(allow_none=True)
    action = fields.Str(required=True)
    description = fields.Str(required=True)
    created_at = fields.DateTime(dump_only=True)


class DetailedStatsQuerySchema(Schema):
    """Schema for detailed statistics query parameters"""

    stat_type = fields.Str(
        required=True,
        validate=validate.OneOf(
            [
                # Admin
                "pending_verifications",
                "reported_reviews",
                "recent_professionals",
                "recent_customers",
                "recent_requests",
                # Professional
                "pending_requests",
                "active_requests",
                "completed_requests",
                "my_reviews",
                "reported_reviews",
                # Customer
                "pending_requests",
                "active_requests",
                "completed_requests",
                "my_reviews",
                "available_services",
            ]
        ),
    )
    start_date = fields.DateTime(required=False)
    end_date = fields.DateTime(required=False)
    page = fields.Int(required=False, missing=1)
    per_page = fields.Int(required=False, missing=10)


class DashboardStatsSchema(Schema):
    """Schema for dashboard statistics"""

    # Admin stats
    total_professionals = fields.Int(required=False)
    verified_professionals = fields.Int(required=False)
    total_customers = fields.Int(required=False)
    active_customers = fields.Int(required=False)
    pending_verifications = fields.Int(required=False)
    reported_reviews = fields.Int(required=False)
    service_requests = fields.Dict(
        keys=fields.Str(), values=fields.Int(), required=False
    )

    # Professional stats
    profile_status = fields.Dict(keys=fields.Str(), values=fields.Raw(), required=False)
    reviews = fields.Dict(keys=fields.Str(), values=fields.Raw(), required=False)

    # Customer stats
    recent_services = fields.Int(required=False)
    reviews_given = fields.Int(required=False)


activity_logs_schema = ActivityLogSchema(many=True)
activity_log_query_schema = ActivityLogQuerySchema()

detailed_stats_query_schema = DetailedStatsQuerySchema()
dashboard_stats_schema = DashboardStatsSchema()

================
File: src/schemas/export.py
================
# src/schemas/export.py
from marshmallow import Schema, fields, validates, ValidationError
from datetime import datetime


class ExportRequestSchema(Schema):
    """Schema for professional's export request parameters"""

    start_date = fields.Str(required=False)
    end_date = fields.Str(required=False)

    @validates("start_date")
    def validate_start_date(self, value):
        try:
            if value:
                datetime.strptime(value, "%Y-%m-%d")
        except ValueError:
            raise ValidationError("Invalid date format. Use YYYY-MM-DD")

    @validates("end_date")
    def validate_end_date(self, value):
        try:
            if value:
                end_date = datetime.strptime(value, "%Y-%m-%d")
                if end_date < datetime.strptime(
                    self.context.get("start_date", "2000-01-01"), "%Y-%m-%d"
                ):
                    raise ValidationError("End date must be after start date")
        except ValueError as e:
            if "must be after start date" in str(e):
                raise
            raise ValidationError("Invalid date format. Use YYYY-MM-DD")


export_request_schema = ExportRequestSchema()

================
File: src/schemas/professional.py
================
from marshmallow import fields, Schema, validate, post_dump

from src.schemas.base import (
    BaseUserSchema,
    BaseProfileUpdateSchema,
    BaseUserInputSchema,
)


class ProfessionalRegisterSchema(BaseUserInputSchema):
    service_type_id = fields.Int(required=True)
    experience_years = fields.Int(required=True, validate=validate.Range(min=0, max=50))
    description = fields.Str(required=True, validate=validate.Length(min=10, max=1000))


class ProfessionalUpdateSchema(BaseProfileUpdateSchema):
    """Schema for professional profile updates"""

    description = fields.Str(validate=validate.Length(min=10, max=1000))


class ProfessionalOutputSchema(BaseUserSchema):
    """Professional output schema - includes all user fields plus professional-specific fields"""

    professional_id = fields.Int(attribute="professional_profile.id", dump_only=True)
    service_type_id = fields.Int(attribute="professional_profile.service_type_id")
    experience_years = fields.Int(attribute="professional_profile.experience_years")
    description = fields.Str(attribute="professional_profile.description")
    is_verified = fields.Bool(
        attribute="professional_profile.is_verified", dump_only=True
    )
    average_rating = fields.Float(
        attribute="professional_profile.average_rating", dump_only=True
    )
    verification_documents = fields.Str(
        attribute="professional_profile.verification_documents", dump_only=True
    )

    @post_dump(pass_many=True)
    def remove_sensitive_fields(self, data, many, **kwargs):
        from flask import g

        if not hasattr(g, "current_user") or g.current_user.role != "admin":
            sensitive_fields = ["verification_documents", "created_at", "last_login"]
            if many:
                for item in data:
                    for field in sensitive_fields:
                        item.pop(field, None)
            else:
                for field in sensitive_fields:
                    data.pop(field, None)
        return data


class ProfessionalQuerySchema(Schema):
    """Schema for validating professional list query parameters"""

    verified = fields.Bool(required=False)
    service_type = fields.Int(required=False)
    page = fields.Int(required=False, missing=1)
    per_page = fields.Int(required=False, missing=10)


professional_output_schema = ProfessionalOutputSchema()
professionals_output_schema = ProfessionalOutputSchema(many=True)
professional_update_schema = ProfessionalUpdateSchema()
professional_query_schema = ProfessionalQuerySchema()
professional_register_schema = ProfessionalRegisterSchema()

================
File: src/schemas/request.py
================
from marshmallow import fields, validate, Schema, validates, ValidationError
from datetime import datetime, timedelta

from src.models import Service


from src.schemas.base import BaseSchema
from src.schemas.service import ServiceOutputSchema


class ServiceRequestInputSchema(Schema):
    """Schema for creating service requests"""

    service_id = fields.Int(required=True)
    preferred_time = fields.DateTime(required=True)
    description = fields.Str(validate=validate.Length(max=1000))

    @validates("preferred_time")
    def validate_preferred_time(self, value):
        """Validate preferred_time constraints"""
        now = datetime.utcnow()

        # Check if time is in the past
        if value <= now:
            raise ValidationError("Preferred time must be in the future")

        # Check if time is more than 7 days in the future
        max_future_date = now + timedelta(days=7)
        if value > max_future_date:
            raise ValidationError(
                "Cannot schedule requests more than 7 days in advance"
            )

        # Check if time is within business hours (9 AM to 6 PM)
        if value.hour < 9 or value.hour >= 18:
            raise ValidationError("Service can only be scheduled between 9 AM and 6 PM")

        # Get service duration and check if service can be completed by 6 PM
        service = Service.query.get(self.context.get("service_id"))
        if service:
            service_end_time = value + timedelta(minutes=service.estimated_time)
            end_time_limit = datetime.combine(
                value.date(), datetime.strptime("18:00", "%H:%M").time()
            )
            if service_end_time > end_time_limit:
                raise ValidationError(
                    "Service cannot be completed by 6 PM with the selected start time"
                )


class SimplifiedCustomerSchema(Schema):
    """Simplified customer schema for nested relationships"""

    id = fields.Int(attribute="id")  # This will be the customer profile id
    user = fields.Nested(lambda: SimplifiedUserSchema())


class SimplifiedProfessionalSchema(Schema):
    """Simplified professional schema for nested relationships"""

    id = fields.Int(attribute="id")  # This will be the professional profile id
    user = fields.Nested(lambda: SimplifiedUserSchema())
    is_verified = fields.Bool(required=True)
    average_rating = fields.Float()


class SimplifiedUserSchema(Schema):
    """Simplified user schema for nested relationships"""

    id = fields.Int(required=True)
    username = fields.Str(required=True)
    full_name = fields.Str(required=True)
    phone = fields.Str(required=True)


class ServiceRequestOutputSchema(Schema):
    """Schema for service request output with proper nested relationships"""

    id = fields.Int(required=True)
    service = fields.Nested(ServiceOutputSchema)
    customer = fields.Nested(SimplifiedCustomerSchema)
    professional = fields.Nested(SimplifiedProfessionalSchema, allow_none=True)
    date_of_request = fields.DateTime(required=True)
    preferred_time = fields.DateTime(required=True)
    status = fields.Str(required=True)
    description = fields.Str(allow_none=True)
    date_of_assignment = fields.DateTime(allow_none=True)
    date_of_completion = fields.DateTime(allow_none=True)
    remarks = fields.Str(allow_none=True)


class ReviewOutputSchema(Schema):
    """Schema for review output data"""

    id = fields.Int(required=True)
    rating = fields.Int(required=True)
    comment = fields.Str(allow_none=True)
    created_at = fields.DateTime(required=True)
    is_reported = fields.Bool(required=True)
    report_reason = fields.Str(allow_none=True)
    service_request = fields.Nested(ServiceRequestOutputSchema)


class ReviewInputSchema(BaseSchema):
    """Schema for submitting reviews"""

    rating = fields.Int(required=True, validate=validate.Range(min=1, max=5))
    comment = fields.Str(validate=validate.Length(max=1000))


class TimeSlotSchema(Schema):
    """Schema for time slot information"""

    start_time = fields.DateTime(required=True)
    end_time = fields.DateTime(required=True)
    status = fields.Str(required=True)  # 'available', 'booked', 'completed'
    service_request = fields.Nested("ServiceRequestOutputSchema", allow_none=True)


class DayScheduleSchema(Schema):
    """Schema for daily schedule"""

    date = fields.Date(required=True)
    time_slots = fields.List(fields.Nested(TimeSlotSchema), required=True)
    total_slots = fields.Int(required=True)
    available_slots = fields.Int(required=True)
    booked_slots = fields.Int(required=True)


class CalendarViewSchema(Schema):
    """Schema for calendar view response"""

    start_date = fields.Date(required=True)
    end_date = fields.Date(required=True)
    days = fields.List(fields.Nested(DayScheduleSchema), required=True)
    total_bookings = fields.Int(required=True)
    available_days = fields.Int(required=True)


# Schema instances
service_request_input_schema = ServiceRequestInputSchema()
service_request_output_schema = ServiceRequestOutputSchema()
service_requests_output_schema = ServiceRequestOutputSchema(many=True)
review_output_schema = ReviewOutputSchema()
reviews_output_schema = ReviewOutputSchema(many=True)

calendar_view_schema = CalendarViewSchema()

================
File: src/schemas/service.py
================
from marshmallow import fields, validate, Schema
from src.schemas.base import BaseSchema


class ServiceInputSchema(BaseSchema):
    """Schema for creating/updating services"""

    name = fields.Str(required=True, validate=validate.Length(min=4, max=100))
    description = fields.Str(required=True, validate=validate.Length(min=1, max=1000))
    base_price = fields.Float(required=True, validate=validate.Range(min=0))
    estimated_time = fields.Int(required=True, validate=validate.Range(min=1))
    is_active = fields.Bool(dump_only=True)


class ServiceUpdateSchema(BaseSchema):
    """Schema for creating/updating services"""

    name = fields.Str(validate=validate.Length(min=4, max=100))
    description = fields.Str(validate=validate.Length(min=1, max=1000))
    base_price = fields.Float(validate=validate.Range(min=0))
    estimated_time = fields.Int(validate=validate.Range(min=1))


class ServiceOutputSchema(Schema):
    """Schema for service output data"""

    id = fields.Int(dump_only=True)
    name = fields.Str(required=True)
    description = fields.Str(required=True)
    base_price = fields.Float(required=True)
    estimated_time = fields.Int(required=True)
    is_active = fields.Bool(required=True)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)


class ServiceQuerySchema(Schema):
    """Schema for validating service list query parameters"""

    is_active = fields.Bool(required=False)
    page = fields.Int(required=False, missing=1)
    per_page = fields.Int(required=False, missing=10)


# Initialize schemas
service_output_schema = ServiceOutputSchema()
services_output_schema = ServiceOutputSchema(many=True)
service_input_schema = ServiceInputSchema()
service_update_schema = ServiceUpdateSchema()
service_query_schema = ServiceQuerySchema()

================
File: src/schemas/user.py
================
from marshmallow import fields, validates

from src.schemas.base import BaseSchema, BaseUserSchema


class AdminAccountSchema(BaseUserSchema):
    """Schema for admin account creation"""

    pass


class BlockUserSchema(BaseSchema):
    """Schema for blocking user requests"""

    reason = fields.Str(required=True, validate=lambda x: len(x.strip()) > 0)


class PasswordUpdateSchema(BaseSchema):
    old_password = fields.Str(required=True)
    new_password = fields.Str(required=True)

    @validates("new_password")
    def validate_new_password(self, value):
        self.validate_password(value)


class DeleteAccountSchema(BaseSchema):
    password = fields.Str(required=True)


admin_output_schema = AdminAccountSchema()
block_user_schema = BlockUserSchema()
password_update_schema = PasswordUpdateSchema()
delete_account_schema = DeleteAccountSchema()

================
File: src/setup_db.py
================
import logging
from faker import Faker
from datetime import datetime, timedelta
import random
import uuid
import os

from src import db

from src.models import (
    User,
    ProfessionalProfile,
    CustomerProfile,
    Service,
    ServiceRequest,
    Review,
    ActivityLog,
)

from src.constants import (
    USER_ROLE_ADMIN,
    USER_ROLE_PROFESSIONAL,
    USER_ROLE_CUSTOMER,
    REQUEST_STATUS_CREATED,
    REQUEST_STATUS_ASSIGNED,
    REQUEST_STATUS_COMPLETED,
    ActivityLogActions,
)

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize Faker
fake = Faker()


def generate_valid_phone():
    """Generate a valid 10-digit phone number starting with a non-zero digit"""
    return f"{random.randint(1, 9)}" + "".join(
        [str(random.randint(0, 9)) for _ in range(9)]
    )


def generate_valid_pincode():
    """Generate a valid 6-digit PIN code not starting with 0"""
    return f"{random.randint(1, 9)}" + "".join(
        [str(random.randint(0, 9)) for _ in range(5)]
    )


def generate_valid_name():
    """Generate a valid full name with proper formatting"""
    name = fake.name()
    # Remove any characters that don't match our validation
    name = "".join(c for c in name if c.isalpha() or c in [" ", "-", "."])
    return name


def generate_valid_address():
    """Generate a valid address under 500 characters"""
    address = fake.address()
    return address[:499] if len(address) > 499 else address


def create_activity_log(user_id, action, entity_id=None, description=None):
    """Helper function to create activity logs"""
    log = ActivityLog(
        user_id=user_id,
        action=action,
        entity_id=entity_id,
        description=description or f"Action: {action}",
    )
    db.session.add(log)
    return log


def setup_database():
    """Initialize database with dummy data"""
    try:
        db.drop_all()
        logger.info("Dropped all tables.")

        db.create_all()
        logger.info("Created all tables.")

        create_dummy_data()
        logger.info("Populated database with dummy data.")

    except Exception as e:
        logger.error(f"Error setting up database: {str(e)}")
        db.session.rollback()
        raise


def create_dummy_data():
    """Create initial data"""
    try:
        # Create admin user
        admin = User(
            username="admin",
            email="admin@example.com",
            full_name="Admin User",
            phone="9876543210",
            address="Admin Office, Main Street, Central District",
            pin_code="110001",
            role=USER_ROLE_ADMIN,
            is_active=True,
            last_login=datetime.utcnow(),
        )
        admin.set_password("Admin@123")
        db.session.add(admin)
        db.session.flush()

        create_activity_log(
            admin.id,
            ActivityLogActions.USER_REGISTER,
            admin.id,
            "Admin account created during system initialization",
        )

        # Log admin login
        create_activity_log(
            admin.id, ActivityLogActions.USER_LOGIN, admin.id, "Initial admin login"
        )

        db.session.commit()
        logger.info("Created admin user")

        # Create services
        services = create_services(admin.id)
        professionals = create_professionals(services, admin.id)
        customers = create_customers()
        create_requests_and_reviews(services, professionals, customers, admin.id)

        # Final commit
        db.session.commit()
        logger.info("Successfully completed database setup")

    except Exception as e:
        logger.error(f"Error in create_dummy_data: {str(e)}")
        db.session.rollback()
        raise


def create_professionals(services, admin_id):
    professionals = []
    verification_doc_template = "verification_doc_{uuid}.pdf"
    doc_directory = os.path.join(
        os.path.dirname(os.path.dirname(__file__)), "static/uploads/verification_docs"
    )

    # Clear existing files and create directory
    clear_static_directory()
    os.makedirs(doc_directory, exist_ok=True)

    service_descriptions = {
        "AC Repair & Service": "Certified AC technician with expertise in all major brands. HVAC certified with experience in split and window units.",
        "Plumbing Service": "Licensed plumber specializing in residential plumbing systems. Expertise in modern plumbing technologies.",
        "Electrical Work": "Certified electrician with focus on home electrical systems. Licensed for residential and commercial work.",
        "Carpentry": "Skilled carpenter with experience in custom furniture and repairs. Specializing in wooden furniture restoration.",
        "House Painting": "Professional painter specializing in interior and exterior painting. Expertise in textured finishes.",
        "Appliance Repair": "Certified appliance technician with multi-brand expertise. Specialized in household appliances.",
        "Home Cleaning": "Professional cleaner with expertise in deep cleaning and sanitization. Trained in modern cleaning methods.",
    }

    verification_statuses = [
        ("rejected", "Insufficient experience documentation"),
        ("pending", "Awaiting additional certifications"),
        ("verified", "All documents verified successfully"),
        ("blocked", "Multiple customer complaints"),
        ("resubmitted", "Updated documents after initial rejection"),
    ]

    try:
        base_date = datetime.utcnow() - timedelta(days=90)

        for i in range(10):  # Increased number of professionals
            service = random.choice(services)
            username = f"pro{i+1}"
            email = f"pro{i+1}@service.com"
            is_active = random.random() < 0.8  # 80% chance of being active

            # Create user with initial pending status
            user = User(
                username=username,
                email=email,
                full_name=generate_valid_name(),
                phone=generate_valid_phone(),
                address=generate_valid_address(),
                pin_code=generate_valid_pincode(),
                role=USER_ROLE_PROFESSIONAL,
                is_active=is_active,
                last_login=base_date - timedelta(days=random.randint(0, 30)),
            )
            user.set_password(f"Pro@{i+1}123")
            db.session.add(user)
            db.session.flush()

            # Initial registration log
            create_activity_log(
                user.id,
                ActivityLogActions.USER_REGISTER,
                user.id,
                f"Professional account created: {username}",
            )

            # Create and save dummy verification document
            doc_filename = verification_doc_template.format(uuid=uuid.uuid4().hex[:8])
            doc_path = os.path.join(doc_directory, doc_filename)
            with open(doc_path, "w") as f:
                f.write(f"Verification documents for {username}\n")
                f.write(f"Service Type: {service.name}\n")
                f.write(f"Experience: {random.randint(2, 15)} years\n")
                f.write("Documents included:\n")
                f.write("1. Identity Proof\n")
                f.write("2. Address Proof\n")
                f.write("3. Professional Certification\n")
                f.write("4. Experience Letters\n")

            # Create professional profile
            profile = ProfessionalProfile(
                user_id=user.id,
                service_type_id=service.id,
                experience_years=random.randint(2, 15),
                description=service_descriptions[service.name],
                is_verified=False,  # Start with unverified status
                verification_documents=doc_filename,
                average_rating=None,  # Initially no rating
            )
            db.session.add(profile)
            db.session.flush()

            # Simulate document updates and verification process
            current_date = base_date
            status_history = random.sample(verification_statuses, random.randint(2, 4))

            for status, reason in status_history:
                current_date += timedelta(days=random.randint(1, 5))

                if status == "rejected":
                    create_activity_log(
                        admin_id,
                        ActivityLogActions.PROFESSIONAL_DOCUMENT_UPDATE,
                        profile.id,
                        f"Verification rejected for {username}: {reason}",
                    )
                    user.is_active = False

                elif status == "resubmitted":
                    # Simulate document update
                    new_doc_filename = verification_doc_template.format(
                        uuid=uuid.uuid4().hex[:8]
                    )
                    new_doc_path = os.path.join(doc_directory, new_doc_filename)
                    with open(new_doc_path, "w") as f:
                        f.write(f"Updated verification documents for {username}\n")
                        f.write("Additional documents included\n")

                    # Update profile with new document
                    profile.verification_documents = new_doc_filename
                    create_activity_log(
                        user.id,
                        ActivityLogActions.PROFESSIONAL_DOCUMENT_UPDATE,
                        profile.id,
                        f"Updated verification documents: {reason}",
                    )

                elif status == "verified":
                    profile.is_verified = True
                    user.is_active = True
                    create_activity_log(
                        admin_id,
                        ActivityLogActions.PROFESSIONAL_VERIFY,
                        profile.id,
                        f"Verified professional {username}: {reason}",
                    )

                elif status == "blocked":
                    user.is_active = False
                    create_activity_log(
                        admin_id,
                        ActivityLogActions.PROFESSIONAL_BLOCK,
                        profile.id,
                        f"Blocked professional {username}: {reason}",
                    )

                    # Simulate unblock after some time
                    if random.random() < 0.4:
                        current_date += timedelta(days=random.randint(10, 30))
                        user.is_active = True
                        create_activity_log(
                            admin_id,
                            ActivityLogActions.PROFESSIONAL_UNBLOCK,
                            profile.id,
                            f"Unblocked professional {username}: Completed necessary improvements",
                        )

            # Simulate service type changes for some professionals
            if random.random() < 0.3:
                new_service = random.choice([s for s in services if s.id != service.id])
                profile.service_type_id = new_service.id
                create_activity_log(
                    user.id,
                    ActivityLogActions.PROFESSIONAL_SERVICE_UPDATE,
                    profile.id,
                    f"Changed service type from {service.name} to {new_service.name}",
                )

            # Simulate profile updates
            for _ in range(random.randint(0, 3)):
                current_date += timedelta(days=random.randint(5, 15))
                update_type = random.choice(
                    ["contact details", "address", "description", "experience details"]
                )
                create_activity_log(
                    user.id,
                    ActivityLogActions.USER_PROFILE_UPDATE,
                    user.id,
                    f"Updated {update_type} for {username}",
                )

            # Simulate password changes
            if random.random() < 0.4:
                create_activity_log(
                    user.id,
                    ActivityLogActions.USER_PASSWORD_CHANGE,
                    user.id,
                    f"Password changed for {username}",
                )

            professionals.append(profile)

        db.session.commit()
        logger.info(
            f"Created {len(professionals)} professionals with comprehensive history"
        )
        return professionals

    except Exception as e:
        logger.error(f"Error creating professionals: {str(e)}")
        db.session.rollback()
        raise


def create_customers():
    customers = []
    base_date = datetime.utcnow() - timedelta(days=90)

    try:
        for i in range(15):  # Increased number for more variety
            username = f"customer{i+1}"
            email = f"customer{i+1}@email.com"
            is_active = random.random() < 0.9  # 90% chance of being active

            user = User(
                username=username,
                email=email,
                full_name=generate_valid_name(),
                phone=generate_valid_phone(),
                address=generate_valid_address(),
                pin_code=generate_valid_pincode(),
                role=USER_ROLE_CUSTOMER,
                is_active=is_active,
                created_at=base_date + timedelta(days=random.randint(0, 30)),
                last_login=datetime.utcnow() - timedelta(days=random.randint(0, 30)),
            )
            user.set_password(f"Customer@{i+1}123")
            db.session.add(user)
            db.session.flush()

            # Log customer registration
            create_activity_log(
                user.id,
                ActivityLogActions.USER_REGISTER,
                user.id,
                f"Customer account created: {username}",
            )

            profile = CustomerProfile(user_id=user.id)
            customers.append(profile)
            db.session.add(profile)
            db.session.flush()

            current_date = user.created_at

            # Simulate profile updates (multiple with different fields)
            num_updates = random.randint(0, 4)
            for _ in range(num_updates):
                current_date += timedelta(days=random.randint(5, 15))
                update_type = random.choice(
                    ["phone number", "address", "email", "pin code"]
                )
                create_activity_log(
                    user.id,
                    ActivityLogActions.USER_PROFILE_UPDATE,
                    user.id,
                    f"Updated {update_type} for {username}",
                )

            # Simulate password changes (with reason)
            num_pwd_changes = random.randint(0, 2)
            for _ in range(num_pwd_changes):
                current_date += timedelta(days=random.randint(10, 30))
                reason = random.choice(
                    [
                        "routine security update",
                        "forgot previous password",
                        "security concern",
                    ]
                )
                create_activity_log(
                    user.id,
                    ActivityLogActions.USER_PASSWORD_CHANGE,
                    user.id,
                    f"Password changed for {username}: {reason}",
                )

            # Simulate login patterns
            num_logins = random.randint(3, 10)
            for _ in range(num_logins):
                current_date += timedelta(days=random.randint(1, 7))
                create_activity_log(
                    user.id,
                    ActivityLogActions.USER_LOGIN,
                    user.id,
                    f"User login from {'mobile' if random.random() < 0.7 else 'web'} device",
                )

            # Simulate account blocks/unblocks for some customers
            if random.random() < 0.2:  # 20% chance of being blocked at some point
                current_date += timedelta(days=random.randint(5, 15))
                block_reason = random.choice(
                    [
                        "Multiple invalid login attempts",
                        "Suspicious activity detected",
                        "Payment issues",
                        "Violation of terms of service",
                    ]
                )
                user.is_active = False
                create_activity_log(
                    None,  # System block
                    ActivityLogActions.CUSTOMER_BLOCK,
                    user.id,
                    f"Customer {username} blocked: {block_reason}",
                )

                # 70% chance of being unblocked later
                if random.random() < 0.7:
                    current_date += timedelta(days=random.randint(1, 7))
                    user.is_active = True
                    create_activity_log(
                        None,  # System unblock
                        ActivityLogActions.CUSTOMER_UNBLOCK,
                        user.id,
                        f"Customer {username} unblocked: Issue resolved",
                    )

            # Simulate account deletion attempts
            if (
                not is_active and random.random() < 0.3
            ):  # 30% chance for inactive accounts
                current_date += timedelta(days=random.randint(1, 5))
                reason = random.choice(
                    [
                        "Requested account closure",
                        "Moving to different location",
                        "No longer needs services",
                    ]
                )
                create_activity_log(
                    user.id,
                    ActivityLogActions.USER_DELETE,
                    user.id,
                    f"Account deletion requested: {reason}",
                )

        db.session.commit()
        logger.info(
            f"Created {len(customers)} customers with comprehensive activity history"
        )
        return customers

    except Exception as e:
        logger.error(f"Error creating customers: {str(e)}")
        db.session.rollback()
        raise


def create_services(admin_id):
    services = []
    service_data = [
        {
            "name": "AC Repair & Service",
            "price": 1500,
            "time": 120,
            "is_active": 0,
            "description": "Professional AC repair and maintenance services including gas refill, component replacement, and thorough cleaning.",
            "history": [
                ("restore", "Service restored after technician verification completed"),
                ("update", "Updated base price from 1200 to 1500"),
                ("delete", "Temporarily suspended due to lack of verified technicians"),
            ],
        },
        {
            "name": "Plumbing Service",
            "price": 800,
            "time": 60,
            "is_active": 1,
            "description": "Expert plumbing services for leak repairs, pipe installation, fixture mounting, and drainage solutions.",
            "history": [
                (
                    "update",
                    "Updated duration from 90 to 60 minutes based on service data",
                ),
                ("update", "Modified description to include drainage solutions"),
            ],
        },
        {
            "name": "Electrical Work",
            "price": 1000,
            "time": 120,
            "is_active": 1,
            "description": "Certified electrical services including wiring, installation, repairs, and safety inspections.",
            "history": [
                ("update", "Added safety inspections to service description"),
                ("delete", "Temporarily disabled for safety protocol update"),
                ("restore", "Restored after implementing new safety protocols"),
            ],
        },
        {
            "name": "Carpentry",
            "price": 1200,
            "time": 180,
            "is_active": 0,
            "description": "Professional carpentry services for furniture repair, custom woodwork, and installations.",
            "history": [
                ("update", "Increased base price from 1000 to 1200"),
                ("delete", "Service suspended for quality review"),
            ],
        },
        {
            "name": "House Painting",
            "price": 3000,
            "time": 480,
            "is_active": 1,
            "description": "Complete house painting services with premium quality paints and professional finish.",
            "history": [
                ("update", "Updated to include premium quality paints"),
                ("update", "Adjusted duration to 8 hours for accurate scheduling"),
            ],
        },
        {
            "name": "Home Cleaning",
            "price": 1000,
            "time": 240,
            "is_active": 1,
            "description": "Professional home cleaning and sanitization services.",
            "history": [
                ("update", "Added sanitization to service scope"),
                ("restore", "Restored with enhanced safety measures"),
                ("update", "Updated price to reflect new safety equipment costs"),
            ],
        },
    ]

    try:
        base_date = datetime.utcnow() - timedelta(days=90)

        for data in service_data:
            service = Service(
                name=data["name"],
                description=data["description"],
                base_price=data["price"],
                estimated_time=data["time"],  # Already in minutes
                is_active=data["is_active"],
                created_at=base_date,
            )
            services.append(service)
            db.session.add(service)
            db.session.flush()

            create_activity_log(
                admin_id,
                ActivityLogActions.SERVICE_CREATE,
                service.id,
                f"Created new service: {service.name}",
            )

            current_date = base_date
            for action_type, action_desc in data.get("history", []):
                current_date += timedelta(days=random.randint(1, 5))

                if action_type == "update":
                    create_activity_log(
                        admin_id,
                        ActivityLogActions.SERVICE_UPDATE,
                        service.id,
                        f"Updated service {service.name}: {action_desc}",
                    )
                elif action_type == "delete":
                    service.is_active = False
                    create_activity_log(
                        admin_id,
                        ActivityLogActions.SERVICE_DELETE,
                        service.id,
                        f"Deactivated service {service.name}: {action_desc}",
                    )
                elif action_type == "restore":
                    service.is_active = True
                    create_activity_log(
                        admin_id,
                        ActivityLogActions.SERVICE_RESTORE,
                        service.id,
                        f"Restored service {service.name}: {action_desc}",
                    )

        db.session.commit()
        return services

    except Exception as e:
        logger.error(f"Error creating services: {str(e)}")
        db.session.rollback()
        raise


def create_requests_and_reviews(services, professionals, customers, admin_id):
    review_templates = [
        ("Excellent service! Very professional and punctual. {}", 5, False),
        ("Great work quality and attention to detail. {}", 5, False),
        (
            "Outstanding service, highly recommended! {}",
            5,
            True,
            "Suspected fake review",
        ),
        ("Good service, met expectations. {}", 4, False),
        ("Professional and efficient work. {}", 4, False),
        ("Quality service but a bit expensive. {}", 4, False),
        ("Average service, room for improvement. {}", 3, False),
        (
            "Work done but communication was poor. {}",
            3,
            True,
            "Unprofessional behavior",
        ),
        ("Below expectations, multiple issues. {}", 2, True, "Service quality issues"),
        ("Very disappointing service. {}", 1, True, "Multiple issues reported"),
    ]

    try:
        base_date = datetime.utcnow() - timedelta(days=90)

        for customer in customers:
            for _ in range(random.randint(2, 5)):  # 2-5 requests per customer
                service = random.choice([s for s in services if s.is_active])
                professional = random.choice(
                    [p for p in professionals if p.user.is_active and p.is_verified]
                )

                request_date = base_date + timedelta(days=random.randint(0, 85))

                # Generate time between 9 AM and max possible start time
                max_start_hour = min(17, 17 - service.estimated_time // 60)
                preferred_time = datetime.combine(
                    request_date.date(),
                    datetime.strptime(
                        f"{random.randint(9, max_start_hour)}:00", "%H:%M"
                    ).time(),
                )

                current_time = datetime.utcnow()
                estimated_completion = preferred_time + timedelta(
                    minutes=service.estimated_time
                )

                # Determine status based on time
                if estimated_completion < current_time:
                    status = REQUEST_STATUS_COMPLETED
                elif preferred_time > current_time and random.random() < 0.7:
                    status = REQUEST_STATUS_ASSIGNED
                else:
                    status = REQUEST_STATUS_CREATED

                # Create service request
                service_request = ServiceRequest(
                    service_id=service.id,
                    customer_id=customer.id,
                    professional_id=professional.id
                    if status != REQUEST_STATUS_CREATED
                    else None,
                    date_of_request=request_date,
                    preferred_time=preferred_time,
                    description=f"Need {service.name} - {fake.sentence()}",
                    status=status,
                    date_of_assignment=request_date
                    + timedelta(hours=random.randint(1, 4))
                    if status != REQUEST_STATUS_CREATED
                    else None,
                    date_of_completion=estimated_completion
                    if status == REQUEST_STATUS_COMPLETED
                    else None,
                    remarks="Service completed successfully."
                    if status == REQUEST_STATUS_COMPLETED
                    else None,
                )
                db.session.add(service_request)
                db.session.flush()

                # Log request creation
                create_activity_log(
                    customer.id,
                    ActivityLogActions.REQUEST_CREATE,
                    service_request.id,
                    f"Created service request for {service.name}",
                )

                # Handle assignment and completion
                if status != REQUEST_STATUS_CREATED:
                    create_activity_log(
                        professional.id,
                        ActivityLogActions.REQUEST_ASSIGN,
                        service_request.id,
                        "Professional accepted the service request",
                    )

                    if status == REQUEST_STATUS_COMPLETED:
                        create_activity_log(
                            professional.id,
                            ActivityLogActions.REQUEST_COMPLETE,
                            service_request.id,
                            "Service completed as scheduled",
                        )

                        # Add review (90% chance for completed services)
                        if random.random() < 0.9:
                            review_template = random.choice(review_templates)
                            review = Review(
                                service_request_id=service_request.id,
                                rating=review_template[1],
                                comment=review_template[0].format(fake.sentence()),
                                is_reported=review_template[2],
                                report_reason=review_template[3]
                                if len(review_template) > 3
                                else None,
                                created_at=estimated_completion
                                + timedelta(days=random.randint(1, 3)),
                            )
                            db.session.add(review)
                            db.session.flush()

                            # Log review creation and handle reports
                            create_activity_log(
                                customer.id,
                                ActivityLogActions.REVIEW_SUBMIT,
                                review.id,
                                f"Submitted {review.rating}-star review",
                            )

                            if review.is_reported:
                                create_activity_log(
                                    professional.id,
                                    ActivityLogActions.REVIEW_REPORT,
                                    review.id,
                                    f"Review reported: {review.report_reason}",
                                )

                                # Admin review action
                                if random.random() < 0.6:
                                    create_activity_log(
                                        admin_id,
                                        ActivityLogActions.REVIEW_DISMISS,
                                        review.id,
                                        "Investigation complete - Review upheld",
                                    )
                                else:
                                    create_activity_log(
                                        admin_id,
                                        ActivityLogActions.REVIEW_REMOVE,
                                        review.id,
                                        "Review removed after investigation",
                                    )

                            # Update professional's rating
                            prof_reviews = (
                                Review.query.join(ServiceRequest)
                                .filter(
                                    ServiceRequest.professional_id == professional.id
                                )
                                .all()
                            )
                            if prof_reviews:
                                total_ratings = sum(r.rating for r in prof_reviews)
                                professional.average_rating = round(
                                    total_ratings / len(prof_reviews), 1
                                )

                # Handle cancellations (30% chance)
                if random.random() < 0.3 and status in [
                    REQUEST_STATUS_CREATED,
                    REQUEST_STATUS_ASSIGNED,
                ]:
                    service_request.status = "cancelled"
                    create_activity_log(
                        customer.id if random.random() < 0.7 else professional.id,
                        ActivityLogActions.REQUEST_CANCEL,
                        service_request.id,
                        "Request cancelled"
                        if status == REQUEST_STATUS_CREATED
                        else "Service cancelled after assignment",
                    )

        db.session.commit()

    except Exception as e:
        logger.error(f"Error creating requests and reviews: {str(e)}")
        db.session.rollback()
        raise


def clear_static_directory():
    """Clear all files from the verification documents upload directory"""
    doc_directory = os.path.join(
        os.path.dirname(os.path.dirname(__file__)), "static/uploads/verification_docs"
    )

    try:
        if os.path.exists(doc_directory):
            # Remove all files in the directory
            for filename in os.listdir(doc_directory):
                file_path = os.path.join(doc_directory, filename)
                if os.path.isfile(file_path):
                    os.unlink(file_path)
            logger.info(f"Cleared all files from {doc_directory}")
        else:
            logger.info(f"Upload directory {doc_directory} does not exist yet")

    except Exception as e:
        logger.error(f"Error clearing static directory: {str(e)}")
        raise

================
File: src/static/exports/service_requests_1_20241129_194212.csv
================
Request ID,Service,Customer Name,Professional Name,Date Requested,Date Completed,Status,Remarks,Rating,Review Comment

================
File: src/static/exports/service_requests_3_20241129_201636.csv
================
Request ID,Service,Customer Name,Professional Name,Date Requested,Date Completed,Status,Remarks,Rating,Review Comment
1,Plumbing Service,Denise Castillo,Scott Snow,2024-11-05 14:45,2024-11-05 17:00,completed,Service completed successfully.,5,"Outstanding service, highly recommended! Several across staff maybe."
2,Plumbing Service,Denise Castillo,Scott Snow,2024-09-11 14:45,2024-09-11 11:00,completed,Service completed successfully.,3,Work done but communication was poor. This common street up policy control accept low.
5,Plumbing Service,Courtney Richardson,Scott Snow,2024-09-05 14:45,2024-09-05 13:00,completed,Service completed successfully.,5,"Outstanding service, highly recommended! Class not approach end green race."
9,Electrical Work,Veronica Ingram,Scott Snow,2024-11-21 14:45,2024-11-21 15:00,completed,Service completed successfully.,4,Professional and efficient work. Go final bit enjoy.
11,Plumbing Service,Veronica Ingram,Scott Snow,2024-11-09 14:45,2024-11-09 12:00,completed,Service completed successfully.,1,Very disappointing service. Chair camera show few account respond.
12,Home Cleaning,Mariah Herrera,Scott Snow,2024-09-28 14:45,2024-09-28 13:00,completed,Service completed successfully.,5,"Outstanding service, highly recommended! Budget watch wish stand for fact."
14,Plumbing Service,Mariah Herrera,Scott Snow,2024-10-26 14:45,2024-10-26 14:00,completed,Service completed successfully.,2,"Below expectations, multiple issues. Allow interesting fear according see."
16,Home Cleaning,Maria Anderson,Scott Snow,2024-10-20 14:45,2024-10-20 15:00,completed,Service completed successfully.,4,"Good service, met expectations. See watch detail college."
17,Plumbing Service,Maria Anderson,Scott Snow,2024-09-26 14:45,2024-09-26 10:00,completed,Service completed successfully.,2,"Below expectations, multiple issues. Record important draw compare manage."
18,House Painting,Tony Lyons,Scott Snow,2024-10-17 14:45,2024-10-17 17:00,completed,Service completed successfully.,4,Quality service but a bit expensive. Process large position.
20,Plumbing Service,Tony Lyons,Scott Snow,2024-10-08 14:45,2024-10-08 12:00,completed,Service completed successfully.,3,"Average service, room for improvement. Rest laugh south fund eye husband economic."
21,Home Cleaning,James Holmes,Scott Snow,2024-09-28 14:45,2024-09-28 15:00,completed,Service completed successfully.,2,"Below expectations, multiple issues. Bar office state majority meet discover material."
25,Electrical Work,Lacey Stephens,Scott Snow,2024-10-23 14:45,2024-10-23 13:00,completed,Service completed successfully.,N/A,N/A
28,Home Cleaning,Lacey Stephens,Scott Snow,2024-09-30 14:45,2024-09-30 14:00,completed,Service completed successfully.,1,Very disappointing service. My year beat song sometimes anyone.
31,Home Cleaning,Brian Morgan,Scott Snow,2024-11-04 14:45,2024-11-04 13:00,completed,Service completed successfully.,4,"Good service, met expectations. Wait face hair war generation."
35,House Painting,Betty Buck,Scott Snow,2024-11-02 14:45,2024-11-02 17:00,completed,Service completed successfully.,4,Quality service but a bit expensive. Material pass show buy.
36,Home Cleaning,Betty Buck,Scott Snow,2024-11-11 14:45,2024-11-11 16:00,completed,Service completed successfully.,N/A,N/A
37,Electrical Work,Michael Maxwell,Scott Snow,2024-10-11 14:45,2024-10-11 14:00,completed,Service completed successfully.,5,"Outstanding service, highly recommended! Girl improve past exist."
41,House Painting,Michael Maxwell,Scott Snow,2024-10-12 14:45,2024-10-12 17:00,completed,Service completed successfully.,5,Great work quality and attention to detail. Less five there itself issue hope ball.
45,Home Cleaning,Elizabeth Thomas,Scott Snow,2024-10-17 14:45,2024-10-17 14:00,completed,Service completed successfully.,1,Very disappointing service. Record real radio.
51,Electrical Work,Kimberly Williams,Scott Snow,2024-10-16 14:45,2024-10-16 16:00,completed,Service completed successfully.,3,Work done but communication was poor. Eat fear enter.
53,Home Cleaning,Kimberly Williams,Scott Snow,2024-11-15 14:45,2024-11-15 14:00,completed,Service completed successfully.,4,"Good service, met expectations. Large movement line alone."
54,Home Cleaning,Kimberly Williams,Scott Snow,2024-11-21 14:45,2024-11-21 16:00,completed,Service completed successfully.,4,Quality service but a bit expensive. Trial information eight shake.

================
File: src/static/exports/service_requests_5_20241129_201351.csv
================
Request ID,Service,Customer Name,Professional Name,Date Requested,Date Completed,Status,Remarks,Rating,Review Comment

================
File: src/tasks.py
================
# src/tasks.py
from celery.schedules import crontab
from datetime import datetime, timedelta
import os
import csv
import traceback

from src.celery_app import celery
from src.models import User, ServiceRequest, ProfessionalProfile, ActivityLog
from src.constants import REQUEST_STATUS_ASSIGNED, REQUEST_STATUS_COMPLETED
from src.utils.notification import NotificationService


def get_app():
    from src.app import create_app

    app = create_app()
    return app


@celery.task
def send_daily_reminders():
    """Send daily reminders to professionals with pending requests"""
    with get_app().app_context():
        try:
            # Get all active professionals
            professionals = (
                ProfessionalProfile.query.join(User)
                .filter(
                    User.is_active == True,  # noqa: E712
                    ProfessionalProfile.is_verified == True,  # noqa: E712
                )
                .all()
            )

            for professional in professionals:
                # Get pending and assigned requests
                pending_requests = ServiceRequest.query.filter(
                    ServiceRequest.professional_id == professional.id,
                    ServiceRequest.status == REQUEST_STATUS_ASSIGNED,
                    ServiceRequest.preferred_time >= datetime.utcnow(),
                    ServiceRequest.preferred_time
                    <= datetime.utcnow() + timedelta(days=1),
                ).all()

                if pending_requests:
                    NotificationService.send_daily_reminder(
                        professional, pending_requests
                    )

            return {
                "status": "success",
                "message": f"Sent reminders to {len(professionals)} professionals",
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}


@celery.task
def generate_monthly_reports():
    """Generate and send monthly activity reports for all users"""
    with get_app().app_context():
        try:
            # Get all active users
            users = User.query.filter_by(is_active=True).all()
            month = (datetime.utcnow() - timedelta(days=1)).strftime("%B %Y")
            start_date = datetime.utcnow().replace(day=1) - timedelta(days=1)

            for user in users:
                report_data = {
                    "name": user.full_name,
                    "month": month,
                    "total_requests": 0,
                    "completed_requests": 0,
                    "average_rating": 0.0,
                    "recent_activities": [],
                }

                if user.role == "professional" and user.professional_profile:
                    # Get professional's statistics
                    requests = ServiceRequest.query.filter(
                        ServiceRequest.professional_id == user.professional_profile.id,
                        ServiceRequest.date_of_request >= start_date,
                    ).all()

                    report_data.update(
                        {
                            "total_requests": len(requests),
                            "completed_requests": sum(
                                1
                                for r in requests
                                if r.status == REQUEST_STATUS_COMPLETED
                            ),
                            "average_rating": user.professional_profile.average_rating
                            or 0.0,
                        }
                    )

                elif user.role == "customer" and user.customer_profile:
                    # Get customer's statistics
                    requests = ServiceRequest.query.filter(
                        ServiceRequest.customer_id == user.customer_profile.id,
                        ServiceRequest.date_of_request >= start_date,
                    ).all()

                    report_data.update(
                        {
                            "total_requests": len(requests),
                            "completed_requests": sum(
                                1
                                for r in requests
                                if r.status == REQUEST_STATUS_COMPLETED
                            ),
                        }
                    )

                # Get recent activities
                activities = (
                    ActivityLog.query.filter(
                        ActivityLog.user_id == user.id,
                        ActivityLog.created_at >= start_date,
                    )
                    .order_by(ActivityLog.created_at.desc())
                    .limit(5)
                    .all()
                )

                report_data["recent_activities"] = [
                    {
                        "description": activity.description,
                        "date": activity.created_at.strftime("%Y-%m-%d %H:%M"),
                    }
                    for activity in activities
                ]

                # Send report email
                NotificationService.send_monthly_report(user, report_data)

            return {
                "status": "success",
                "message": f"Generated reports for {len(users)} users",
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}


@celery.task(bind=True)
def generate_service_requests_csv(
    self, professional_id, start_date=None, end_date=None, user_email=None
):
    """Generate CSV export of service requests"""
    app = get_app()

    with app.app_context():
        try:
            # Update state to STARTED
            self.update_state(state="STARTED", meta={"info": "Task starting"})

            # Build query
            query = ServiceRequest.query.filter_by(status=REQUEST_STATUS_COMPLETED)

            if professional_id:
                query = query.filter_by(professional_id=professional_id)
                # Verify professional exists
                professional = ProfessionalProfile.query.get(professional_id)
                if not professional:
                    raise ValueError(
                        f"Professional with ID {professional_id} not found"
                    )

            if start_date:
                query = query.filter(
                    ServiceRequest.date_of_request
                    >= datetime.strptime(start_date, "%Y-%m-%d")
                )
            if end_date:
                query = query.filter(
                    ServiceRequest.date_of_request
                    <= datetime.strptime(end_date, "%Y-%m-%d")
                )

            # Get requests
            requests = query.all()

            if not requests:
                return {
                    "status": "success",
                    "message": "No completed service requests found for the given criteria",
                    "total_records": 0,
                    "professional_id": professional_id,
                }

            # Generate filename
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"service_requests_{professional_id}_{timestamp}.csv"
            filepath = os.path.join(app.root_path, "static/exports", filename)

            # Create directory if doesn't exist
            os.makedirs(os.path.dirname(filepath), exist_ok=True)

            # Write CSV
            with open(filepath, "w", newline="") as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(
                    [
                        "Request ID",
                        "Service",
                        "Customer Name",
                        "Professional Name",
                        "Date Requested",
                        "Date Completed",
                        "Status",
                        "Remarks",
                        "Rating",
                        "Review Comment",
                    ]
                )

                for request in requests:
                    review = request.review
                    writer.writerow(
                        [
                            request.id,
                            request.service.name,
                            request.customer.user.full_name,
                            request.professional.user.full_name
                            if request.professional
                            else "N/A",
                            request.date_of_request.strftime("%Y-%m-%d %H:%M"),
                            request.date_of_completion.strftime("%Y-%m-%d %H:%M")
                            if request.date_of_completion
                            else "N/A",
                            request.status,
                            request.remarks or "N/A",
                            review.rating if review else "N/A",
                            review.comment if review and review.comment else "N/A",
                        ]
                    )

            # Send notification
            if user_email:
                NotificationService.send_email(
                    to=user_email,
                    subject="Service Requests Export Complete",
                    template="emails/export_complete.html",
                    data={
                        "filename": filename,
                        "total_records": len(requests),
                    },
                )
            return {
                "status": "success",
                "filename": filename,
                "total_records": len(requests),
                "professional_id": professional_id,
                "message": f"Successfully exported {len(requests)} service requests",
            }

        except Exception as e:
            self.update_state(
                state="FAILURE",
                meta={
                    "exc_type": type(e).__name__,
                    "exc_message": str(e),
                    "traceback": traceback.format_exc(),
                },
            )
            raise


@celery.on_after_configure.connect
def setup_periodic_tasks(sender, **kwargs):
    # Send daily reminders at 6 PM every day
    sender.add_periodic_task(
        crontab(hour=18, minute=0), send_daily_reminders.s(), name="daily-reminders"
    )

    # Generate monthly reports on the 1st of every month at 1 AM
    sender.add_periodic_task(
        crontab(day_of_month=1, hour=1, minute=0),
        generate_monthly_reports.s(),
        name="monthly-reports",
    )

================
File: src/utils/api.py
================
from http import HTTPStatus
from flask import jsonify
from src import db


class APIResponse:
    """Unified API Response Handler"""

    @staticmethod
    def success(data=None, message=None, status_code=HTTPStatus.OK, pagination=None):
        response = {
            "status": "success",
            "status_code": status_code,
            "data": data,
        }
        if message:
            response["detail"] = message
        if pagination:
            response["pagination"] = pagination

        return jsonify(response), status_code

    @staticmethod
    def error(message, status_code=HTTPStatus.BAD_REQUEST, error_type=None):
        """
        Centralized error response method
        Also handles database rollback when needed
        """
        if status_code >= 500:  # Server errors
            db.session.rollback()

        response = {
            "status": "failure",
            "status_code": status_code,
            "detail": message,
            "error_type": error_type,
        }
        return jsonify(response), status_code


# Register error handler with Flask app
def register_error_handlers(app):
    @app.errorhandler(Exception)
    def handle_exception(e):
        """Handle all unhandled exceptions"""
        app.logger.error(f"Unhandled exception: {str(e)}")
        return APIResponse.error(
            message="An unexpected error occurred",
            status_code=HTTPStatus.INTERNAL_SERVER_ERROR,
        )

    @app.errorhandler(HTTPStatus.NOT_FOUND)
    def handle_404(e):
        """Handle 404 errors"""
        return APIResponse.error(
            message="Resource not found",
            status_code=HTTPStatus.NOT_FOUND,
        )

    @app.errorhandler(HTTPStatus.METHOD_NOT_ALLOWED)
    def handle_405(e):
        """Handle 405 errors"""
        return APIResponse.error(
            message="Method not allowed",
            status_code=HTTPStatus.METHOD_NOT_ALLOWED,
        )

================
File: src/utils/auth.py
================
from functools import wraps
from flask import request, current_app
from http import HTTPStatus
import jwt
from datetime import datetime, timedelta
from src.models import User
from src.utils.api import APIResponse


def generate_token(user_id: int, role: str) -> str:
    """Generate JWT token for user"""
    payload = {
        "user_id": user_id,
        "role": role,
        "exp": datetime.utcnow() + timedelta(days=1),
    }
    return jwt.encode(payload, current_app.config["SECRET_KEY"], algorithm="HS256")


def token_required(f):
    """Decorator to protect routes with JWT"""

    @wraps(f)
    def decorated(*args, **kwargs):
        token = None
        if "Authorization" in request.headers:
            auth_header = request.headers["Authorization"]
            try:
                token = auth_header.split(" ")[1]
            except IndexError:
                return APIResponse.error(
                    message="Invalid token format",
                    status_code=HTTPStatus.UNAUTHORIZED,
                    error_type="InvalidTokenFormat",
                )

        if not token:
            return APIResponse.error(
                message="Token is missing",
                status_code=HTTPStatus.UNAUTHORIZED,
                error_type="MissingToken",
            )

        try:
            data = jwt.decode(
                token, current_app.config["SECRET_KEY"], algorithms=["HS256"]
            )
            current_user = User.query.get(data["user_id"])
            if not current_user or not current_user.is_active:
                return APIResponse.error(
                    message="Invalid or inactive user",
                    status_code=HTTPStatus.UNAUTHORIZED,
                    error_type="InvalidUser",
                )
        except jwt.ExpiredSignatureError:
            return APIResponse.error(
                message="Token has expired",
                status_code=HTTPStatus.UNAUTHORIZED,
                error_type="TokenExpired",
            )
        except jwt.InvalidTokenError:
            return APIResponse.error(
                message="Invalid token",
                status_code=HTTPStatus.UNAUTHORIZED,
                error_type="InvalidToken",
            )

        return f(current_user, *args, **kwargs)

    return decorated


def role_required(*roles):
    """Decorator to restrict routes based on user role"""

    def decorator(f):
        @wraps(f)
        def decorated_function(current_user, *args, **kwargs):
            if current_user.role not in roles:
                return APIResponse.error(
                    message="Permission denied",
                    status_code=HTTPStatus.FORBIDDEN,
                    error_type="InsufficientPermissions",
                )
            return f(current_user, *args, **kwargs)

        return decorated_function

    return decorator

================
File: src/utils/cache.py
================
from functools import wraps
from flask import request
from flask_caching import Cache
import hashlib

# Initialize cache
cache = Cache()


def init_cache(app):
    """Initialize Redis cache with app configuration"""
    cache_config = {
        "CACHE_TYPE": "redis",
        "CACHE_REDIS_URL": "redis://localhost:6379/0",
        "CACHE_DEFAULT_TIMEOUT": 300,  # 5 minutes default
    }
    app.config.update(cache_config)
    cache.init_app(app)


def cache_key(*args, **kwargs):
    """Generate a cache key based on request parameters"""
    path = request.path
    args = str(hash(frozenset(request.args.items())))
    return f"view/{path}-{args}"


def clear_cache_by_pattern(pattern):
    """Clear all cache entries matching a pattern"""
    if hasattr(cache, "_client"):
        # Get all keys matching the pattern
        keys = cache._client.scan_iter(match=pattern)
        # Delete all matching keys
        for key in keys:
            cache._client.delete(key)


# Cache decorators
def cached_with_auth(timeout=300):
    """Cache decorator that includes user authentication in cache key"""

    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # Get auth token from request
            auth_token = request.headers.get("Authorization", "")

            # Create unique cache key including auth info
            key_parts = [
                request.path,
                str(hash(frozenset(request.args.items()))),
                hashlib.md5(auth_token.encode()).hexdigest(),
            ]
            cache_key = "view/" + "-".join(key_parts)

            # Try to get response from cache
            rv = cache.get(cache_key)
            if rv is not None:
                return rv

            # If not in cache, generate response and cache it
            rv = f(*args, **kwargs)
            cache.set(cache_key, rv, timeout=timeout)
            return rv

        return decorated_function

    return decorator


def cache_invalidate(*patterns):
    """Decorator to invalidate cache patterns after function execution"""

    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            result = f(*args, **kwargs)
            for pattern in patterns:
                clear_cache_by_pattern(pattern)
            return result

        return decorated_function

    return decorator

================
File: src/utils/file.py
================
import os
from werkzeug.utils import secure_filename
from datetime import datetime
import uuid
from flask import current_app
from typing import Optional, Tuple

ALLOWED_EXTENSIONS = {"pdf", "jpg", "jpeg", "png"}
UPLOAD_FOLDER = "../static/uploads/verification_docs"


def allowed_file(filename: str) -> bool:
    """Check if file extension is allowed"""
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS


def save_verification_document(file) -> Tuple[Optional[str], Optional[str]]:
    """
    Save verification document and return the filename
    Returns: (filename, error_message)
    """
    if not file:
        return None, "No file provided"

    if not allowed_file(file.filename):
        return (
            None,
            f"Invalid file type. Allowed types: {', '.join(ALLOWED_EXTENSIONS)}",
        )

    # Create unique filename
    original_filename = secure_filename(file.filename)
    extension = original_filename.rsplit(".", 1)[1].lower()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    unique_id = str(uuid.uuid4().hex[:8])
    filename = f"verification_{timestamp}_{unique_id}.{extension}"

    # Ensure upload directory exists
    os.makedirs(os.path.join(current_app.root_path, UPLOAD_FOLDER), exist_ok=True)

    try:
        file_path = os.path.join(current_app.root_path, UPLOAD_FOLDER, filename)
        file.save(file_path)
        return filename, None
    except Exception as e:
        return None, f"Error saving file: {str(e)}"


def delete_verification_document(filename: str) -> bool:
    """Delete a verification document"""
    if not filename:
        return False

    try:
        file_path = os.path.join(current_app.root_path, UPLOAD_FOLDER, filename)
        if os.path.exists(file_path):
            os.remove(file_path)
            return True
        return False
    except Exception:
        return False

================
File: src/utils/notification.py
================
# src/utils/notification.py

from flask import current_app, render_template
from flask_mail import Mail, Message
from typing import List, Optional, Dict, Any

mail = Mail()


class EmailTemplate:
    """Email template constants"""

    VERIFICATION_APPROVED = "emails/verification_approved.html"
    SERVICE_REQUEST_ASSIGNED = "emails/service_request_assigned.html"
    SERVICE_REQUEST_COMPLETED = "emails/service_request_completed.html"
    MONTHLY_REPORT = "emails/monthly_report.html"
    DAILY_REMINDER = "emails/daily_reminder.html"


class NotificationService:
    @staticmethod
    def send_email(
        to: str,
        subject: str,
        template: str,
        data: Dict[str, Any],
        cc: Optional[List[str]] = None,
        bcc: Optional[List[str]] = None,
    ) -> bool:
        """
        Send an email using a template
        Returns: True if successful, False otherwise
        """
        try:
            msg = Message(
                subject,
                sender=current_app.config["MAIL_DEFAULT_SENDER"],
                recipients=[to],
                cc=cc,
                bcc=bcc,
            )

            # Render template with data
            msg.html = render_template(template, **data)

            mail.send(msg)
            return True
        except Exception as e:
            current_app.logger.error(f"Failed to send email: {str(e)}")
            return False

    @classmethod
    def send_verification_approved(cls, professional):
        """Send verification approval email"""
        return cls.send_email(
            to=professional.user.email,
            subject="Professional Verification Approved",
            template=EmailTemplate.VERIFICATION_APPROVED,
            data={
                "name": professional.user.full_name,
                "service": professional.service_type.name,
            },
        )

    @classmethod
    def send_service_request_notification(
        cls, service_request, template: str, subject: str
    ):
        """Send service request related notifications"""
        return cls.send_email(
            to=service_request.customer.user.email,
            subject=subject,
            template=template,
            data={
                "customer_name": service_request.customer.user.full_name,
                "service_name": service_request.service.name,
                "date": service_request.preferred_time.strftime("%Y-%m-%d %H:%M"),
                "professional_name": service_request.professional.user.full_name
                if service_request.professional
                else None,
                "request_id": service_request.id,
            },
        )

    @classmethod
    def send_daily_reminder(cls, professional, pending_requests):
        """Send daily reminder to professional"""
        return cls.send_email(
            to=professional.user.email,
            subject="Daily Service Requests Update",
            template=EmailTemplate.DAILY_REMINDER,
            data={
                "name": professional.user.full_name,
                "pending_requests": pending_requests,
            },
        )

    @classmethod
    def send_monthly_report(cls, user, report_data):
        """Send monthly activity report"""
        return cls.send_email(
            to=user.email,
            subject=f"Monthly Activity Report - {report_data['month']}",
            template=EmailTemplate.MONTHLY_REPORT,
            data=report_data,
        )

================
File: src/utils/request.py
================
from datetime import datetime, timedelta
from typing import Optional, Tuple, Dict, List
from sqlalchemy import func

from src.constants import (
    REQUEST_STATUS_ASSIGNED,
    REQUEST_STATUS_COMPLETED,
)

from src.models import ServiceRequest, ProfessionalProfile, Service
from src.utils.cache import cache


def _get_cache_key_availability(professional_id: int, date: datetime.date) -> str:
    """Generate cache key for professional availability"""
    return f"availability:{professional_id}:{date.isoformat()}"


def _get_cache_key_schedule(
    professional_id: int, start_date: datetime.date, end_date: datetime.date
) -> str:
    """Generate cache key for professional schedule"""
    return f"schedule:{professional_id}:{start_date.isoformat()}:{end_date.isoformat()}"


def check_booking_availability(
    professional_id: int, preferred_time: datetime, service_duration: int
) -> Tuple[bool, Optional[str]]:
    """
    Check if a professional is available for a booking time slot.
    Args:
        professional_id: ID of the professional
        preferred_time: Requested start time
        service_duration: Service duration in minutes (must be an integer)

    Returns:
        Tuple of (is_available, error_message)
    """
    # Generate cache key for the day
    cache_key = _get_cache_key_availability(professional_id, preferred_time.date())

    # Try to get cached availability data
    cached_data = cache.get(cache_key)

    if cached_data is not None:
        # Use cached data to check availability
        return _check_availability_from_cached_data(
            cached_data, preferred_time, service_duration
        )

    try:
        # Ensure service_duration is an integer
        duration_minutes = int(service_duration)
    except (TypeError, ValueError):
        return False, "Invalid service duration"

    # Calculate the end time of the requested booking
    booking_end_time = preferred_time + timedelta(minutes=duration_minutes)

    # Get all assigned requests for the professional
    assigned_requests = (
        ServiceRequest.query.join(Service)
        .filter(
            ServiceRequest.professional_id == professional_id,
            ServiceRequest.status == REQUEST_STATUS_ASSIGNED,
            # Get requests on the same day
            func.date(ServiceRequest.preferred_time) == preferred_time.date(),
        )
        .all()
    )

    # Prepare availability data for caching
    availability_data = []
    for request in assigned_requests:
        start = request.preferred_time
        end = start + timedelta(minutes=int(request.service.estimated_time))
        availability_data.append(
            {
                "start": start.isoformat(),
                "end": end.isoformat(),
                "request_id": request.id,
            }
        )

    # Cache the availability data for 15 minutes
    cache.set(cache_key, availability_data, timeout=900)

    # Check for overlaps
    for existing_request in assigned_requests:
        existing_start = existing_request.preferred_time
        existing_end = existing_start + timedelta(
            minutes=int(existing_request.service.estimated_time)
        )

        # Check for any overlap
        if (
            (
                existing_start <= preferred_time < existing_end
            )  # New booking starts during existing
            or (
                existing_start < booking_end_time <= existing_end
            )  # New booking ends during existing
            or (
                preferred_time <= existing_start and booking_end_time >= existing_end
            )  # New booking encompasses existing
        ):
            return (
                False,
                "Professional has an overlapping booking during this time slot",
            )

    # Check if service extends beyond business hours (6 PM)
    end_time_limit = datetime.combine(
        preferred_time.date(), datetime.strptime("18:00", "%H:%M").time()
    )
    if booking_end_time > end_time_limit:
        return False, "Service cannot extend beyond 6 PM"

    return True, None


def _check_availability_from_cached_data(
    cached_data: List[Dict], preferred_time: datetime, service_duration: int
) -> Tuple[bool, Optional[str]]:
    """Check availability using cached data"""
    booking_end_time = preferred_time + timedelta(minutes=service_duration)

    # Check business hours first
    end_time_limit = datetime.combine(
        preferred_time.date(), datetime.strptime("18:00", "%H:%M").time()
    )
    if booking_end_time > end_time_limit:
        return False, "Service cannot extend beyond 6 PM"

    # Check overlaps with cached bookings
    for booking in cached_data:
        existing_start = datetime.fromisoformat(booking["start"])
        existing_end = datetime.fromisoformat(booking["end"])

        if (
            (existing_start <= preferred_time < existing_end)
            or (existing_start < booking_end_time <= existing_end)
            or (preferred_time <= existing_start and booking_end_time >= existing_end)
        ):
            return (
                False,
                "Professional has an overlapping booking during this time slot",
            )

    return True, None


def generate_available_slots(
    start_date: datetime.date, end_date: datetime.date, slot_duration: int = 60
) -> list:
    """Generate available time slots for given date range"""
    slots = []
    current_date = start_date

    while current_date <= end_date:
        # Generate slots for business hours (9 AM to 6 PM)
        current_time = datetime.combine(
            current_date, datetime.min.time().replace(hour=9)
        )
        end_time = datetime.combine(current_date, datetime.min.time().replace(hour=18))

        while current_time < end_time:
            slot_end = current_time + timedelta(minutes=slot_duration)
            if slot_end <= end_time:
                slots.append(
                    {
                        "start_time": current_time,
                        "end_time": slot_end,
                        "status": "available",
                        "service_request": None,
                    }
                )
            current_time = slot_end

        current_date += timedelta(days=1)

    return slots


def get_professional_schedule(
    professional_id: int,
    start_date: datetime.date,
    end_date: datetime.date,
    service_id: Optional[int] = None,
) -> dict:
    """Get professional's schedule including booked and available slots"""

    # Try to get cached schedule
    cache_key = _get_cache_key_schedule(professional_id, start_date, end_date)
    cached_schedule = cache.get(cache_key)

    if cached_schedule is not None:
        return cached_schedule

    # Get professional's service duration
    professional = ProfessionalProfile.query.get_or_404(professional_id)
    if service_id:
        service = Service.query.get_or_404(service_id)
        slot_duration = service.estimated_time
    else:
        slot_duration = professional.service_type.estimated_time

    # Generate all possible time slots
    all_slots = generate_available_slots(start_date, end_date, slot_duration)

    # Get professional's bookings
    bookings = (
        ServiceRequest.query.filter(
            ServiceRequest.professional_id == professional_id,
            ServiceRequest.status.in_(
                [
                    REQUEST_STATUS_ASSIGNED,
                    REQUEST_STATUS_COMPLETED,
                ]
            ),
            ServiceRequest.preferred_time
            >= datetime.combine(start_date, datetime.min.time()),
            ServiceRequest.preferred_time
            <= datetime.combine(end_date, datetime.max.time()),
        )
        .order_by(ServiceRequest.preferred_time)
        .all()
    )

    # Organize slots by date
    schedule = {}
    for slot in all_slots:
        date = slot["start_time"].date()
        if date not in schedule:
            schedule[date] = {
                "date": date,
                "time_slots": [],
                "total_slots": 0,
                "available_slots": 0,
                "booked_slots": 0,
            }
        schedule[date]["time_slots"].append(slot)
        schedule[date]["total_slots"] += 1
        schedule[date]["available_slots"] += 1

    # Mark booked slots
    for booking in bookings:
        booking_end = booking.preferred_time + timedelta(
            minutes=booking.service.estimated_time
        )
        booking_date = booking.preferred_time.date()

        if booking_date in schedule:
            for slot in schedule[booking_date]["time_slots"]:
                # Check if slot overlaps with booking
                if (
                    slot["start_time"] <= booking.preferred_time < slot["end_time"]
                    or slot["start_time"] < booking_end <= slot["end_time"]
                ):
                    slot["status"] = (
                        "booked"
                        if booking.status != REQUEST_STATUS_COMPLETED
                        else "completed"
                    )
                    slot["service_request"] = booking
                    schedule[booking_date]["available_slots"] -= 1
                    schedule[booking_date]["booked_slots"] += 1

    # Prepare response
    response = {
        "start_date": start_date,
        "end_date": end_date,
        "days": list(schedule.values()),
        "total_bookings": len(bookings),
        "available_days": sum(
            1 for day in schedule.values() if day["available_slots"] > 0
        ),
    }

    # Cache the schedule for 5 minutes
    cache.set(cache_key, response, timeout=300)

    return response

================
File: src/utils/user.py
================
from src.models import User
from src.utils.api import APIResponse
from http import HTTPStatus


def check_existing_user(username: str, email: str) -> tuple[bool, tuple]:
    """Check if username or email already exists"""
    if User.query.filter_by(username=username).first():
        return True, APIResponse.error(
            "Username already exists", HTTPStatus.CONFLICT, "DuplicateUsername"
        )

    if User.query.filter_by(email=email).first():
        return True, APIResponse.error(
            "Email already exists", HTTPStatus.CONFLICT, "DuplicateEmail"
        )

    return False, None

================
File: templates/emails/daily_reminder.html
================
<!DOCTYPE html>
<html>

<body>
    <h2>Daily Service Requests Update</h2>
    <p>Dear {{ name }},</p>
    {% if pending_requests %}
    <p>You have {{ pending_requests|length }} pending service requests:</p>
    <ul>
        {% for request in pending_requests %}
        <li>
            {{ request.service.name }} - {{ request.preferred_time.strftime('%Y-%m-%d %H:%M') }}
            <br>Location: {{ request.customer.user.address }}
        </li>
        {% endfor %}
    </ul>
    {% else %}
    <p>You have no pending service requests today.</p>
    {% endif %}
    <p>Best regards,<br>Household Services Team</p>
</body>

</html>

================
File: templates/emails/export_complete.html
================
{# templates/emails/export_complete.html #}
<!DOCTYPE html>
<html>

<body>
    <h2>Export Complete</h2>
    <p>Dear {{ name }},</p>
    <p>Your service requests export has been completed successfully.</p>

    <h3>Export Details:</h3>
    <ul>
        <li>Filename: {{ filename }}</li>
        <li>Total Records: {{ total_records }}</li>
    </ul>

    <p>You can download the export file from the admin dashboard.</p>

    <p>Best regards,<br>Household Services Team</p>
</body>

</html>

================
File: templates/emails/monthly_report.html
================
<!DOCTYPE html>
<html>

<body>
    <h2>Monthly Activity Report - {{ month }}</h2>
    <p>Dear {{ name }},</p>

    <h3>Service Request Summary</h3>
    <ul>
        <li>Total Requests: {{ total_requests }}</li>
        <li>Completed Requests: {{ completed_requests }}</li>
        <li>Average Rating: {{ average_rating }}</li>
        {% if revenue %}
        <li>Total Revenue: {{ revenue }}</li>
        {% endif %}
    </ul>

    {% if recent_activities %}
    <h3>Recent Activities</h3>
    <ul>
        {% for activity in recent_activities %}
        <li>{{ activity.description }} - {{ activity.date }}</li>
        {% endfor %}
    </ul>
    {% endif %}

    <p>Best regards,<br>Household Services Team</p>
</body>

</html>

================
File: templates/emails/service_request_assigned.html
================
<!DOCTYPE html>
<html>

<body>
    <h2>Professional Assigned</h2>
    <p>Dear {{ customer_name }},</p>
    <p>A professional has been assigned to your service request:</p>
    <ul>
        <li>Service: {{ service_name }}</li>
        <li>Date: {{ date }}</li>
        <li>Professional: {{ professional_name }}</li>
        <li>Request ID: {{ request_id }}</li>
    </ul>
    <p>Best regards,<br>Household Services Team</p>
</body>

</html>

================
File: templates/emails/verification_approved.html
================
<!DOCTYPE html>
<html>

<body>
    <h2>Verification Approved</h2>
    <p>Dear {{ name }},</p>
    <p>Congratulations! Your professional verification for {{ service }} has been approved. You can now start accepting
        service requests.</p>
    <p>Best regards,<br>Household Services Team</p>
</body>

</html>
